<html>
<head><title>DEVELOPMENT variables.</title>
<link rel=stylesheet type="text/css" href="formabinit.css">
</head>
<body bgcolor="#ffffff">
<hr>
<a name="top"></a>

<h1>ABINIT, developper input variables:</h1>
<h2>List and description.</h2>

<hr>

<p>This document lists and provides the description
of the name (keywords) of the input
variables "for developpers" to be used in the
main input file of the abinit code.

<p>The new user is advised to read first the
  <a href="../users/new_user_guide.html">new user's guide</a>,
  before reading the present file. It will be easier to discover the
  present file with the help of the <a href="../tutorial/welcome.html">tutorial</a>.

<p>When the user is sufficiently familiarized with ABINIT, the reading of the
  ~abinit/doc/users/tuning file might be useful. For response-function calculations using
  abinit, please read <a href="../users/respfn_help.html">the response function help file</a>

<h5>Copyright (C) 1998-2014 ABINIT group (DCA, XG, RC)
<br> This file is distributed under the terms of the GNU General Public License, see
~abinit/COPYING or <a href="http://www.gnu.org/copyleft/gpl.txt">
http://www.gnu.org/copyleft/gpl.txt </a>.
<br> For the initials of contributors, see ~abinit/doc/developers/contributors.txt .
</h5>

<script type="text/javascript" src="list_internal_links.js"> </script>

<script type="text/javascript" src="list_htmlfiles_input_variables.js"> </script>

<h3><b> Content of the file : alphabetical list of developper variables.</b></h3>
 <br>A.
 <a href="vardev.html#accesswff">accesswff</a>&nbsp;&nbsp;
 <br>B.
 <a href="vardev.html#builtintest">builtintest</a>&nbsp;&nbsp;
 <a href="vardev.html#bs_interp_kmult">bs_interp_kmult</a>&nbsp;&nbsp;
 <a href="vardev.html#bs_interp_mode">bs_interp_mode</a>&nbsp;&nbsp;
 <a href="vardev.html#bs_interp_prep">bs_interp_prep</a>&nbsp;&nbsp;
 <br>C.
 <a href="vardev.html#cgtyphf">cgtyphf</a>&nbsp;&nbsp;
 <br>D.
 <a href="vardev.html#densty">densty</a>&nbsp;&nbsp;
 <a href="vardev.html#dmft_dc">dmft_dc</a>&nbsp;&nbsp;
 <a href="vardev.html#dmft_entropy">dmft_entropy</a>&nbsp;&nbsp;
 <a href="vardev.html#dmft_iter">dmft_iter</a>&nbsp;&nbsp;
 <a href="vardev.html#dmft_nlambda">dmft_nlambda</a>&nbsp;&nbsp;
 <a href="vardev.html#dmft_mxsf">dmft_mxsf</a>&nbsp;&nbsp;
 <a href="vardev.html#dmft_nwli">dmft_nwli</a>&nbsp;&nbsp;
 <a href="vardev.html#dmft_nwlo">dmft_nwlo</a>&nbsp;&nbsp;
 <a href="vardev.html#dmft_read_occnd">dmft_read_occnd</a>&nbsp;&nbsp;
 <a href="vardev.html#dmft_rslf">dmft_rslf</a>&nbsp;&nbsp;
 <a href="vardev.html#dmft_solv">dmft_solv</a>&nbsp;&nbsp;
 <a href="vardev.html#dmft_tollc">dmft_tollc</a>&nbsp;&nbsp;
 <a href="vardev.html#dmftbandf">dmftbandf</a>&nbsp;&nbsp;
 <a href="vardev.html#dmftbandi">dmftbandi</a>&nbsp;&nbsp;
 <a href="vardev.html#dmftcheck">dmftcheck</a>&nbsp;&nbsp;
 <a href="vardev.html#dmftctqmc_check">dmftctqmc_check<a>&nbsp;&nbsp;
 <a href="vardev.html#dmftctqmc_correl">dmftctqmc_correl<a>&nbsp;&nbsp;
 <a href="vardev.html#dmftctqmc_grnns">dmftctqmc_grnns<a>&nbsp;&nbsp;
 <a href="vardev.html#dmftctqmc_meas">dmftctqmc_meas<a>&nbsp;&nbsp;
 <a href="vardev.html#dmftctqmc_mrka">dmftctqmc_mrka<a>&nbsp;&nbsp;
 <a href="vardev.html#dmftctqmc_mov">dmftctqmc_mov<a>&nbsp;&nbsp;
 <a href="vardev.html#dmftctqmc_order">dmftctqmc_order<a>&nbsp;&nbsp;
 <a href="vardev.html#dmftctqmc_gmove">dmftctqmc_gmove<a>&nbsp;&nbsp;
 <a href="vardev.html#dmftqmc_l">dmftqmc_l<a>&nbsp;&nbsp;
 <a href="vardev.html#dmftqmc_n">dmftqmc_n<a>&nbsp;&nbsp;
 <a href="vardev.html#dmftqmc_seed">dmftqmc_seed<a>&nbsp;&nbsp;
 <a href="vardev.html#dmftqmc_therm">dmftqmc_therm<a>&nbsp;&nbsp;
 <br>E.
 <a href="vardev.html#effmass">effmass</a>&nbsp;&nbsp;
 <a href="vardev.html#eshift">eshift</a>&nbsp;&nbsp;
 <a href="vardev.html#exchmix">exchmix</a>&nbsp;&nbsp;
 <a href="vardev.html#exchn2n3d">exchn2n3d</a>&nbsp;&nbsp;
 <br>F.
 <a href="vardev.html#fermie_nest">fermie_nest</a>&nbsp;&nbsp;
 <a href="vardev.html#fftalg">fftalg</a>&nbsp;&nbsp;
 <a href="vardev.html#fftcache">fftcache</a>&nbsp;&nbsp;
 <a href="vardev.html#fft_opt_lob">fft_opt_lob</a>&nbsp;&nbsp;
 <a href="vardev.html#freqsusin">freqsusin</a>&nbsp;&nbsp;
 <a href="vardev.html#freqsuslo">freqsuslo</a>&nbsp;&nbsp;
 <br>G.
 <a href="vardev.html#getgam_eig2nkq">getgam_eig2nkq</a>&nbsp;&nbsp;
 <a href="vardev.html#getwfkfine">getwfkfine</a>&nbsp;&nbsp;
 <br>H.
 <br>I.
 <a href="vardev.html#idyson">idyson</a>&nbsp;&nbsp;
 <a href="vardev.html#ikhxc">ikhxc</a>&nbsp;&nbsp;
 <a href="vardev.html#intexact">intexact</a>&nbsp;&nbsp;
 <a href="vardev.html#intxc">intxc</a>&nbsp;&nbsp;
 <a href="vardev.html#iprcch">iprcch</a>&nbsp;&nbsp;
 <a href="vardev.html#iprcfc">iprcfc</a>&nbsp;&nbsp;
 <a href="vardev.html#irandom">irandom</a>&nbsp;&nbsp;
 <a href="vardev.html#irdvdw">irdvdw</a>&nbsp;&nbsp;
 <a href="vardev.html#irdwfkfine">irdwfkfine</a>&nbsp;&nbsp;
 <a href="vardev.html#isecur">isecur</a>&nbsp;&nbsp;
 <a href="vardev.html#istatr">istatr</a>&nbsp;&nbsp;
 <a href="vardev.html#istatshft">istatshft</a>&nbsp;&nbsp;
 <a href="vardev.html#istwfk">istwfk</a>&nbsp;&nbsp;
 <br>J.
 <br>K.
 <br>L.
 <a href="vardev.html#ldgapp">ldgapp</a>&nbsp;&nbsp;
 <a href="vardev.html#lotf_classic">lotf_classic</a>&nbsp;&nbsp;
 <a href="vardev.html#lotf_nitex">lotf_nitex</a>&nbsp;&nbsp;
 <a href="vardev.html#lotf_nneigx">lotf_nneigx</a>&nbsp;&nbsp;
 <a href="vardev.html#lotf_version">lotf_version</a>&nbsp;&nbsp;
 <br>M.
 <a href="vardev.html#macro_uj">macro_uj</a>&nbsp;&nbsp;
 <a href="vardev.html#maxnsym">maxnsym</a>&nbsp;&nbsp;
 <a href="vardev.html#mem_test">mem_test</a>&nbsp;&nbsp;
 <a href="vardev.html#mqgrid">mqgrid</a>&nbsp;&nbsp;
 <br>N.
 <a href="vardev.html#nbandsus">nbandsus</a>&nbsp;&nbsp;
 <a href="vardev.html#nbdblock">nbdblock</a>&nbsp;&nbsp;
 <a href="vardev.html#nctime">nctime</a>&nbsp;&nbsp;
 <a href="vardev.html#ndyson">ndyson</a>&nbsp;&nbsp;
 <a href="vardev.html#nloalg">nloalg</a>&nbsp;&nbsp;
 <a href="vardev.html#nnsclo">nnsclo</a>&nbsp;&nbsp;
 <a href="vardev.html#nnsclohf">nnsclohf</a>&nbsp;&nbsp;
 <a href="vardev.html#normpawu">normpawu</a>&nbsp;&nbsp;
 <a href="vardev.html#noseft">noseft</a>&nbsp;&nbsp;
 <a href="vardev.html#noseinert">noseinert</a>&nbsp;&nbsp;
 <a href="vardev.html#npulayit">npulayit</a>&nbsp;&nbsp;
 <a href="vardev.html#nscforder">nscforder</a>&nbsp;&nbsp;
 <br>O.
 <a href="vardev.html#optforces">optforces</a>&nbsp;&nbsp;
 <a href="vardev.html#optfreqsus">optfreqsus</a>&nbsp;&nbsp;
 <a href="vardev.html#optnlxccc">optnlxccc</a>&nbsp;&nbsp;
 <a href="vardev.html#ortalg">ortalg</a>&nbsp;&nbsp;
 <br>P.
 <a href="vardev.html#papiopt">papiopt</a>&nbsp;&nbsp;
 <a href="vardev.html#pawprt_b">pawprt_b</a>&nbsp;&nbsp;
 <a href="vardev.html#pawprt_k">pawprt_k</a>&nbsp;&nbsp;
 <a href="vardev.html#pawujat">pawujat</a>&nbsp;&nbsp;
 <a href="vardev.html#pawujrad">pawujrad</a>&nbsp;&nbsp;
 <a href="vardev.html#pawujv">pawujv</a>&nbsp;&nbsp;
 <a href="vardev.html#plowan_bandi">plowan_bandi</a>&nbsp;&nbsp;
 <a href="vardev.html#plowan_bandf">plowan_bandf</a>&nbsp;&nbsp;
 <a href="vardev.html#plowan_compute">plowan_compute</a>&nbsp;&nbsp;
 <a href="vardev.html#plowan_iatom">plowan_iatom</a>&nbsp;&nbsp;
 <a href="vardev.html#plowan_it">plowan_it</a>&nbsp;&nbsp;
 <a href="vardev.html#plowan_lcalc">plowan_lcalc</a>&nbsp;&nbsp;
 <a href="vardev.html#plowan_natom">plowan_natom</a>&nbsp;&nbsp;
 <a href="vardev.html#plowan_nbl">plowan_nbl</a>&nbsp;&nbsp;
 <a href="vardev.html#plowan_nt">plowan_nt</a>&nbsp;&nbsp;
 <a href="vardev.html#plowan_projcalc">plowan_projcalc</a>&nbsp;&nbsp;
 <a href="vardev.html#plowan_realspace">plowan_realspace</a>&nbsp;&nbsp;
 <a href="vardev.html#prepscphon">prepscphon</a>&nbsp;&nbsp;
 <a href="vardev.html#prtbltztrp">prtbltztrp</a>&nbsp;&nbsp;
 <a href="vardev.html#prtcif">prtcif</a>&nbsp;&nbsp;
 <a href="vardev.html#prtdipole">prtdipole</a>&nbsp;&nbsp;
 <a href="vardev.html#prtnest">prtnest</a>&nbsp;&nbsp;
 <a href="vardev.html#prtposcar">prtposcar</a>&nbsp;&nbsp;
 <a href="vardev.html#prtvdw">prtvdw</a>&nbsp;&nbsp;
 <br>Q.
 <br>R.
 <a href="vardev.html#recefermi">recefermi</a>&nbsp;&nbsp;
 <a href="vardev.html#recgratio">recgratio</a>&nbsp;&nbsp;
 <a href="vardev.html#recnpath">recnpath</a>&nbsp;&nbsp;
 <a href="vardev.html#recnrec">recnrec</a>&nbsp;&nbsp;
 <a href="vardev.html#recptrott">recptrott</a>&nbsp;&nbsp;
 <a href="vardev.html#recrcut">recrcut</a>&nbsp;&nbsp;
 <a href="vardev.html#rectesteg">rectesteg</a>&nbsp;&nbsp;
 <a href="vardev.html#rectolden">rectolden</a>&nbsp;&nbsp;
 <br>S.
 <a href="vardev.html#suskxcrs">suskxcrs</a>&nbsp;&nbsp;
 <a href="vardev.html#symmorphi">symmorphi</a>&nbsp;&nbsp;
 <br>T.
 <a href="vardev.html#tfkinfunc">tfkinfunc</a>&nbsp;&nbsp;
 <a href="vardev.html#tolrde">tolrde</a>&nbsp;&nbsp;
 <br>U.
 <a href="vardev.html#use_gemm_nonlop">use_gemm_nonlop</a>&nbsp;&nbsp;
 <a href="vardev.html#use_nonscf_gkk">use_nonscf_gkk</a>&nbsp;&nbsp;
 <a href="vardev.html#useri">useria, userib, useric, userid, userie</a>&nbsp;&nbsp;
 <a href="vardev.html#userr">userra, userrb, userrc, userrd, userre</a>&nbsp;&nbsp;
 <a href="vardev.html#useylm">useylm</a>&nbsp;&nbsp;
 <br>V.
 <a href="vardev.html#vdw_nfrag">vdw_nfrag</a>&nbsp;&nbsp;
 <a href="vardev.html#vdw_tol">vdw_tol</a>&nbsp;&nbsp;
 <a href="vardev.html#vdw_typfrag">vdw_typfrag</a>&nbsp;&nbsp;
 <a href="vardev.html#vdw_df_acutmin">vdw_df_acutmin</a>&nbsp;&nbsp;
 <a href="vardev.html#vdw_df_aratio">vdw_df_aratio</a>&nbsp;&nbsp;
 <a href="vardev.html#vdw_df_damax">vdw_df_damax</a>&nbsp;&nbsp;
 <a href="vardev.html#vdw_df_damin">vdw_df_damin</a>&nbsp;&nbsp;
 <a href="vardev.html#vdw_df_dcut">vdw_df_dcut</a>&nbsp;&nbsp;
 <a href="vardev.html#vdw_df_dratio">vdw_df_dratio</a>&nbsp;&nbsp;
 <a href="vardev.html#vdw_df_dsoft">vdw_df_dsoft</a>&nbsp;&nbsp;
 <a href="vardev.html#vdw_df_gcut">vdw_df_gcut</a>&nbsp;&nbsp;
 <a href="vardev.html#vdw_df_ndpts">vdw_df_ndpts</a>&nbsp;&nbsp;
 <a href="vardev.html#vdw_df_ngpts">vdw_df_ngpts</a>&nbsp;&nbsp;
 <a href="vardev.html#vdw_df_nqpts">vdw_df_nqpts</a>&nbsp;&nbsp;
 <a href="vardev.html#vdw_df_nrpts">vdw_df_nrpts</a>&nbsp;&nbsp;
 <a href="vardev.html#vdw_df_nsmooth">vdw_df_nsmooth</a>&nbsp;&nbsp;
 <a href="vardev.html#vdw_df_phisoft">vdw_df_phisoft</a>&nbsp;&nbsp;
 <a href="vardev.html#vdw_df_qcut">vdw_df_qcut</a>&nbsp;&nbsp;
 <a href="vardev.html#vdw_df_qratio">vdw_df_qratio</a>&nbsp;&nbsp;
 <a href="vardev.html#vdw_df_rcut">vdw_df_rcut</a>&nbsp;&nbsp;
 <a href="vardev.html#vdw_df_rsoft">vdw_df_rsoft</a>&nbsp;&nbsp;
 <a href="vardev.html#vdw_df_tolerance">vdw_df_tolerance</a>&nbsp;&nbsp;
 <a href="vardev.html#vdw_df_tweaks">vdw_df_tweaks</a>&nbsp;&nbsp;
 <a href="vardev.html#vdw_df_zab">vdw_df_zab</a>&nbsp;&nbsp;
 <a href="vardev.html#vdw_supercell">vdw_supercell</a>&nbsp;&nbsp;
 <a href="vardev.html#vdw_xc">vdw_xc</a>&nbsp;&nbsp;
 <br>W.
 <a href="vardev.html#wfoptalg">wfoptalg</a>&nbsp;&nbsp;
 <br>X.
 <a href="vardev.html#xc_tb09_c">xc_tb09_c</a>&nbsp;&nbsp;
 <br>Y.
 <br>Z.

<br><br><br><br><hr>

<br><font id="title"><a name="accesswff">accesswff</a></font>
<br><font id="definition">Mnemonics: ACCESS to WaveFunction Files </font>
<br><font id="category">Characteristic: <a href="../users/abinit_help.html#develop">DEVELOP</a> </font>
<br><font id="vartype">Variable type: integer parameter </font>
<br><font id="default">Default is 0. However, if mpi_io is available, <b>accesswff</b> will be set to 1 for the datasets for which <a href="varpar.html#paral_kgb">paral_kgb</a>=1, while an explicit mention of <b>accesswff</b> in the input file will override this intermediate default.</font>
<br><font id="text"><p>
Governs the method of access to the
internal wavefunction files. Relevant only for the wavefunctions
files for which the corresponding "mkmem"-type variable is zero, that
is, for the wavefunctions that are not kept in core memory.
<ul>
<li>0 =&gt; Use standard Fortran IO routines</li>
<li>1 =&gt; Use MPI/IO routines</li>
<li>2 =&gt; Directly use NetCDF routines (this option is not available)</li>
<li>3 =&gt; Use ETSF_IO routines, creating NetCDF files according to the ETSF specification.</li>
</ul>
<br>
In case <b>accesswff</b>=1, note the following. MPI/IO routines might be much more efficient than usual Fortran IO
routines in the case of a large number of processors, with a pool of
disks attached globally to the processors, but not one disk attached
to each processor. For a cluster of workstations, where each processor
has his own temporaries, the use of <b>accesswff</b>=0 might be perfectly
allright. This option is useful only if one is using the band-FFT parallelism.
MPI/IO routines are available in the MPI-2 library, but usually not in the MPI-1 library. So, perhaps you cannot
use <b>accesswff</b>=1.
<br>
In case <b>accesswff</b>=3, note that not only the wavefunctions will be written using the ETSF_IO routines,
but also, the same input variable governs the writing of the density and potential, that can also be
written using ETSF_IO routines. In order to use <b>accesswff</b>=3, you need to have the plug-in library ETSF_IO
working (see the documentation of the build system).
References :
<ul>
 <li>
 "Specification of an extensible and portable file format for electronic structure and crystallographic data",
 X. Gonze, C.-O. Almbladh, A. Cucca, D. Caliste, C. Freysoldt, M. Marques, V. Olevano, Y. Pouillon, M.J. Verstraete,
 Comput. Mat. Science 43, 1056 (2008)
 </li>
 <li>
 "Sharing electronic structure and crystallographic data with ETSF_IO",
 D. Caliste, Y. Pouillon, M.J. Verstraete, V. Olevano, X. Gonze,
 Comput. Physics Communications 179, 748 (2008)
 </li>
 <li>
see also <a href="http://www.etsf.eu/fileformats">http://www.etsf.eu/fileformats</a>.
 </li>
</ul>
</font>

<br><br><br><br><a href=#top>Go to the top</a>
<B> | </B><a href="keyhr.html#list">Complete list of input variables</a><hr>

<br><font id="title"><a name="builtintest">builtintest</a></font><br>
<br><font id="definition">Mnemonics: BUIT-IN TEST number </font>
<br><font id="category">Characteristic: <a href="../users/abinit_help.html#develop">DEVELOP</a> </font>
<br><font id="vartype">Variable type: integer </font>
<br><font id="default">Default is 0</font>
<br><font id="text">
<p>
When <b>builtintest</b> is non-zero, the input file is a special one, that runs very quickly, 
and that is accompanied by  
a specific analysis by ABINIT, at the end of the run, against a hard-coded value of total energy
(and possibly stresses, forces ...). The echo of the analysis is done in the STATUS file.
In particular, such built-in tests can be used to check quickly
whether ABINIT fallbacks have been connected or not (bigdft, etsf_io, libxc, wannier90).
At present, <b>builtintest</b>=1 ... 7 are allowed. See more information in tests/built-in/README .
</font>

<br><br><br><br><a href=#top>Go to the top</a>
<B> | </B><a href="keyhr.html#list">Complete list of input variables</a><hr>

<br><font id="title"><a name="bs_interp_kmult">bs_interp_kmult</a></font>
 <br><font id="definition">Mnemonics: Bethe-Salpeter INTERPolation K-point MULTiplication factors</font>
 <br><font id="category">Characteristic: BS </font>
 <br><font id="vartype">Variable type: integer(3) </font>
 <br><font id="default">Default is (0,0,0) </font>
 <br><font id="text">
 <p>
 Only relevant if <a href="vardev.html#bs_interp_mode">bs_interp_mode</a>&gt; 0 and <a href="vargw.html#bs_algorithm">bs_algorithm</a>=2.</p>
 <p>
 <b>bs_interp_kmult</b> defines the number of divisions used to generate the dense mesh in the interpolation.
 <a href="varbas.html#ngkpt">ngkpt</a> of the dense mesh = <b>bs_interp_kmult(:)</b> * <a href="varbas.html#ngkpt">ngkpt</a> of the coarse mesh.
</font>

<br><br><br><br><a href=#top>Go to the top</a>
<B> | </B><a href="keyhr.html#list">Complete list of input variables</a><hr>

<br><font id="title"><a name="bs_interp_mode">bs_interp_mode</a></font>
 <br><font id="definition">Mnemonics: Bethe-Salpeter INTERPolation MODE</font>
 <br><font id="category">Characteristic: BS </font>
 <br><font id="vartype">Variable type: integer </font>
 <br><font id="default">Default is 0 </font>
 <br><font id="text">
 <p>
 Only relevant if <a href="vardev.html#bs_interp_mode">bs_interp_mode</a>&gt; 0 and <a href="vargw.html#bs_algorithm">bs_algorithm</a>=2.</p>
 <p>
 <b>bs_interp_mode</b> selects the mode of interpolation:
 <ul>
  <li> 0 =&gt; No interpolation. Standard BSE is performed
  <li> 1 =&gt; Simple interpolation
  <li> 2 =&gt; Treatment of the divergence on the whole set of dense k-points
  <li> 3 =&gt; Treatment of the divergence along the diagonal in k-space and simple interpolation elsewhere.
 </ul>
</font>

<br><br><br><br><a href=#top>Go to the top</a>
<B> | </B><a href="keyhr.html#list">Complete list of input variables</a><hr>

<br><font id="title"><a name="bs_interp_prep">bs_interp_prep</a></font>
 <br><font id="definition">Mnemonics: Bethe-Salpeter INTERPolation PREParation</font>
 <br><font id="category">Characteristic: BS </font>
 <br><font id="vartype">Variable type: integer </font>
 <br><font id="default">Default is 0 </font>
 <br><font id="text">
 <p>
 Only relevant if <a href="vardev.html#bs_interp_mode">bs_interp_mode</a>&gt; 0 and <a href="vargw.html#bs_algorithm">bs_algorithm</a>=2.</p>
 <p>
 <b>bs_interp_prep</b> allows to trigger the preparation of the interpolation with method 2 or method 3.
 It generates the decomposition of BSR in a,b,c coefficients used for the interpolation.
</font>



<br><br><br><br><a href=#top>Go to the top</a>
<B> | </B><a href="keyhr.html#list">Complete list of input variables</a><hr>

<br><font id="title"><a name="cgtyphf">cgtyphf</a></font>
<br><font id="definition">Mnemonics: Type of Conjugate Gradient used for Fock exact exchange</font>
<br><font id="category">Characteristic: <a href="../users/abinit_help.html#develop">DEVELOP</a> </font>
<br><font id="vartype">Variable type: integer parameter </font>
<br><font id="default">Default is 0 if <a href="varint.html#usefock">usefock</a> &lt;=0, and 2 <a href="varint.html#usefock">usefock</a> &lt;=1.</font>
<br><font id="text"> 
<p>
Gives how is calculated Fock exact exchange contribution in the conjugate gradient,
in the SCF case.  
<br>The Default value is 0 when <a href="varint.html#usefock">usefock</a> &lt;=0.
Default value is 2 when <a href="varint.html#usefock">usefock</a> &lt;=1 and corresponds to calculate the Fock 
exact exchange contribution each time in the conjugate gradient. The value 1 corresponds to calculate the Fock 
exact exchange contribution only for the initial guess (not for the gradient direction) in the conjugate gradient </font>


<br><br><br><br><a href=#top>Go to the top</a>
<B> | </B><a href="keyhr.html#list">Complete list of input variables</a><hr>

<br><font id="title"><a name="densty">densty</a></font><br>
<br><font id="definition">Mnemonics: initial DENSity for each TYpe of atom </font>
<br><font id="category">Characteristic: <a href="../users/abinit_help.html#develop">DEVELOP</a> </font>
<br><font id="vartype">Variable type: real array densty(<a href="varbas.html#ntypat">ntypat</a>) </font>
<br><font id="default">Default is 0.0d0.</font>
<br><font id="text">
<p>
Gives a rough description
of the initial GS density, for each type of atom.
This value is only used to create
the first exchange and correlation potential,
and is not used anymore afterwards.
For the time being, it corresponds to an average
radius (a.u.) of the density, and is used to generate
a gaussian density. If set to 0.0d0, an optimized value is used.
<br>No meaning for RF calculations.</font>

<br><br><br><br><a href=#top>Go to the top</a>
<B> | </B><a href="keyhr.html#list">Complete list of input variables</a><hr>

<br><font id="title"><a name="dmft_dc">dmft_dc</a></font>
<br><font id="definition">Mnemonics: Dynamical Mean Fied Theory: Double Counting</font>
<br><font id="category">Characteristic: <a href="../users/abinit_help.html#develop">DEVELOP</a>  </font>
<br><font id="vartype">Variable type: integer  </font>
<br><font id="default">Default is 1 </font>
<br><font id="text">
<p>
<br> Value of double counting used for DMFT. Only value 1 is activated for the moment and is the FLL double counting.
</font>

<br><br><br><br><a href=#top>Go to the top</a>
<B> | </B><a href="keyhr.html#list">Complete list of input variables</a><hr>

<br><font id="title"><a name="dmft_entropy">dmft_entropy</a></font>
<br><font id="definition">Mnemonics: Dynamical Mean Fied Theory: Energy TOTal</font>
<br><font id="category">Characteristic: <a href="../users/abinit_help.html#develop">DEVELOP</a>  </font>
<br><font id="vartype">Variable type: integer  </font>
<br><font id="default">Default is 0 </font>
<br><font id="text">
<p>
<br>Enable the calculation of the entropy (if dmft_entropy=1) within the DMFT framework and so allows the calculation of the total energy (free energy). 
DMFT framework must be activate (see <a href="vardev.html#usedmft">usedmft</a>).</br>
In the current implementation, this is only possible with <a href="vardev.html#dmft_solv">dmft_solv</a>=5 (Continuous Time Quantum Monte Carlo).

</font>

<br><br><br><br><a href=#top>Go to the top</a>
<B> | </B><a href="keyhr.html#list">Complete list of input variables</a><hr>

<br><font id="title"><a name="dmft_iter">dmft_iter</a></font>
<br><font id="definition">Mnemonics: Dynamical Mean Fied Theory: number of ITERation </font>
<br><font id="category">Characteristic: <a href="../users/abinit_help.html#develop">DEVELOP</a>  </font>
<br><font id="vartype">Variable type: integer  </font>
<br><font id="default">Default is 0 </font>
<br><font id="text">
<p>
<br> Number of iterations for the DMFT inner loop.
</font>

<br><br><br><br><a href=#top>Go to the top</a>
<B> | </B><a href="keyhr.html#list">Complete list of input variables</a><hr>

<br><font id="title"><a name="dmft_nlambda">dmft_nlambda</a></font>
<br><font id="definition">Mnemonics: Dynamical Mean Fied Theory: Number of LAMBDA points</font>
<br><font id="category">Characteristic: <a href="../users/abinit_help.html#develop">DEVELOP</a>  </font>
<br><font id="vartype">Variable type: integer  </font>
<br><font id="default">Default is 6 </font>
<br><font id="text">
<p>
<br> In the case of the free energy calculation (see <a href="vardev.html#usedmft">dmft_entropy</a>) with the DMFT framework (see <a href="vardev.html#usedmft">usedmft</a>), this variable gives the number of integration points for the thermodynamical integration. </br>
Its value must be greater or equal to 3.
</font>

<br><br><br><br><a href=#top>Go to the top</a>
<B> | </B><a href="keyhr.html#list">Complete list of input variables</a><hr>

<br><font id="title"><a name="dmft_mxsf">dmft_mxsf</a></font>
<br><font id="definition">Mnemonics: Dynamical Mean Fied Theory: MiXing parameter for the SelF energy </font>
<br><font id="category">Characteristic: <a href="../users/abinit_help.html#develop">DEVELOP</a>  </font>
<br><font id="vartype">Variable type: real  </font>
<br><font id="default">Default is 0.3 </font>
<br><font id="text">
<p>
<br> Mixing parameter for the simple mixing of the self-energy.
</font>

<br><br><br><br><a href=#top>Go to the top</a>
<B> | </B><a href="keyhr.html#list">Complete list of input variables</a><hr>

<br><font id="title"><a name="dmft_nwli">dmft_nwli</a></font>
<br><font id="definition">Mnemonics: Dynamical Mean Fied Theory: Number of frequency omega (W) in the LInear mesh </font>
<br><font id="category">Characteristic: <a href="../users/abinit_help.html#develop">DEVELOP</a>  </font>
<br><font id="vartype">Variable type: integer  </font>
<br><font id="default">Default is 0  </font>
<br><font id="text">
<p>
<br> Number of Matsubara frequencies (linear  mesh)
</font>

<br><br><br><br><a href=#top>Go to the top</a>
<B> | </B><a href="keyhr.html#list">Complete list of input variables</a><hr>

<br><font id="title"><a name="dmft_nwlo">dmft_nwlo</a></font>
<br><font id="definition">Mnemonics: Dynamical Mean Fied Theory: Number of frequency omega (W) in the log mesh </font>
<br><font id="category">Characteristic: <a href="../users/abinit_help.html#develop">DEVELOP</a>  </font>
<br><font id="vartype">Variable type: integer  </font>
<br><font id="default">Default is 0  </font>
<br><font id="text">
<p>
<br> Number of frequencies in the log mesh.
</font>

<br><br><br><br><a href=#top>Go to the top</a>
<B> | </B><a href="keyhr.html#list">Complete list of input variables</a><hr>

<br><font id="title"><a name="dmft_read_occnd">dmft_read_occnd</a></font>
<br><font id="definition">Mnemonics: Dynamical Mean Fied Theory: Read Occupations (Non Diagonal) </font>
<br><font id="category">Characteristic: <a href="../users/abinit_help.html#develop">DEVELOP</a>  </font>
<br><font id="vartype">Variable type: integer  </font>
<br><font id="default">Default is 0  </font>
<br><font id="text">
<p>
<br> Flag to read/write Occupations as computed in DMFT. This flag is useful
     to restart a DFT+DMFT calculation with self-consistency over electronic density.
     The occupations are written each time a DMFT loop is finished. So if the calculations stops
     because the time limit is reached, this option offers the possibility to restart the self-consistent loop
     over density at the point where it stopped.
<ul>
<li> 0=&gt;  Occupations are written but never read.
<li> 1=&gt;  Occupations are read from I_DMFTOCCND, where I is the root for input files.
<li> 2=&gt;  Occupations are read from O_DMFTOCCND, where O is the root for output files.
</ul>

An alternative and more simple way to restart a DFT+DMFT calculation is to use the density file (obtained with <a href="varfil.html#prtden">prtden</a>=1
or <a href="varfil.html#prtden">prtden</a>=-1)

</font>

<br><br><br><br><a href=#top>Go to the top</a>
<B> | </B><a href="keyhr.html#list">Complete list of input variables</a><hr>

<br><font id="title"><a name="dmft_rslf">dmft_rslf</a></font>
<br><font id="definition">Mnemonics: Dynamical Mean Fied Theory: Read SeLF energy </font>
<br><font id="category">Characteristic: <a href="../users/abinit_help.html#develop">DEVELOP</a>  </font>
<br><font id="vartype">Variable type: integer  </font>
<br><font id="default">Default is 0  </font>
<br><font id="text">
<p>
<br> Flag to read/write Self-Energy. If put to one, self-energy is written and read at each LDA iteration.
</font>

<br><br><br><br><a href=#top>Go to the top</a>
<B> | </B><a href="keyhr.html#list">Complete list of input variables</a><hr>

<br><font id="title"><a name="dmft_solv">dmft_solv</a></font>
<br><font id="definition">Mnemonics: Dynamical Mean Fied Theory: choice of SOLVer </font>
<br><font id="category">Characteristic: <a href="../users/abinit_help.html#develop">DEVELOP</a>  </font>
<br><font id="vartype">Variable type: real  </font>
<br><font id="default">Default is 0  </font>
<br><font id="text">
<p>
<br> Choice of solver for the Impurity model.
<ul>
<li> 1=&gt; LDA+U self-energy is used (for testing purpose)
<li> 2=&gt; Hubbard one solver. The Hubbard one solver is an approximation which gives a rough description of correlated Mott insulators. It should not be used for metals.
<li> 5=&gt; Continuous Time Quantum Monte Carlo (CTQMC) solver CT-Hyb (Hybridization expansion as published in  
<a href="http://journals.aps.org/prl/abstract/10.1103/PhysRevLett.97.076405"> Phys. Rev. Lett 97, 076405, (2006)</a>) in the density density representation and without Spin Orbit Coupling.
CTQMC calculations are much more time consuming that Hubbard I calculations. Nevertheless, the calculation if fully parallelised.
</ul>
<br> WARNING: CT-QMC should be used for correlated metals. Even if correlated (Mott) insulators, QMC is expected to be much more precise: Hubbard one is an approximation !
<br> See the usefull variables for CT-QMC solver :
	<a href="vardev.html#dmftctqmc_check">dmftctqmc_check</a>,
	<a href="vardev.html#dmftctqmc_correl">dmftctqmc_correl</a>,
	<a href="vardev.html#dmftctqmc_gmove">dmftctqmc_gmove</a>,
	<a href="vardev.html#dmftctqmc_grnns">dmftctqmc_grnns</a>,
	<a href="vardev.html#dmftctqmc_meas">dmftctqmc_meas</a>,
	<a href="vardev.html#dmftctqmc_mrka">dmftctqmc_mrka</a>,
	<a href="vardev.html#dmftctqmc_mov">dmftctqmc_mov</a>,
	<a href="vardev.html#dmftctqmc_order">dmftctqmc_order</a>,
	<a href="vardev.html#dmftqmc_l">dmftqmc_l</a>,
	<a href="vardev.html#dmftqmc_n">dmftqmc_n</a>,
	<a href="vardev.html#dmftqmc_therm">dmftqmc_seed</a>,
	<a href="vardev.html#dmftqmc_therm">dmftqmc_therm</a>
</font>

<br><br><br><br><a href=#top>Go to the top</a>
<B> | </B><a href="keyhr.html#list">Complete list of input variables</a><hr>

<br><font id="title"><a name="dmft_t2g">dmft_t2g</a></font>
<br><font id="definition">Mnemonics: Dynamical Mean Fied Theory: t2g orbitals </font>
<br><font id="category">Characteristic: <a href="../users/abinit_help.html#develop">DEVELOP</a>  </font>
<br><font id="vartype">Variable type: integer  </font>
<br><font id="default">Default is 0  </font>
<br><font id="text">
<p>
<br> Can be set to 1 only if in cubic symetric. It enable to carry a DFT+DMFT calculations only on t2g orbitals.
</font>

<br><br><br><br><a href=#top>Go to the top</a>
<B> | </B><a href="keyhr.html#list">Complete list of input variables</a><hr>

<br><font id="title"><a name="dmft_tollc">dmft_tollc</a></font>
<br><font id="definition">Mnemonics: Dynamical Mean Fied Theory: Tolerance on Local Charge for convergency of the DMFT loop </font>
<br><font id="category">Characteristic: <a href="../users/abinit_help.html#develop">DEVELOP</a>  </font>
<br><font id="vartype">Variable type: real  </font>
<br><font id="default">Default is 0.00001  </font>
<br><font id="text">
<p>
<br> Tolerance for the variation of Local Charge during iterations of the DMFT Loop.
<br> The default value is good for fast calculations. However, to obtain good convergency of the DFT Loop,
the DMFT Loop needs a better convergence criterion.
</font>

<br><br><br><br><a href=#top>Go to the top</a>
<B> | </B><a href="keyhr.html#list">Complete list of input variables</a><hr>

<br><font id="title"><a name="dmftbandf">dmftbandf</a></font>
<br><font id="title"><a name="dmftbandi">dmftbandi</a></font>
<br><font id="definition">Mnemonics: (to be described) </font>
<br><font id="category">Characteristic: <a href="../users/abinit_help.html#develop">DEVELOP</a>  </font>
<br><font id="vartype">Variable type: (to be described)  </font>
<br><font id="default">Default is 0 </font>
<br><font id="text">
<p>
	<br> dmftbandi and dmftbandf are the first and last bands taken into account in the Projected Local
	Orbitals scheme of LDA+DMFT. They thus define the energy window used to define Wannier Functions.
	(see  Amadon, B., Lechermann, F., Georges, A., Jollet, F., Wehling, T. O., and Lichtenstein, A. I. Phys. Rev. B 77(20), (2008).)

</font>

<br><br><br><br><a href=#top>Go to the top</a>
<B> | </B><a href="keyhr.html#list">Complete list of input variables</a><hr>

<br><font id="title"><a name="dmftcheck">dmftcheck</a></font>
<br><font id="definition">Mnemonics: Dynamical Mean Fied Theory: CHECKs </font>
<br><font id="category">Characteristic: <a href="../users/abinit_help.html#develop">DEVELOP</a>  </font>
<br><font id="vartype">Variable type: integer  </font>
<br><font id="default">Default is 0 </font>
<br><font id="text">
<p>
<br> (Introduced by B. Amadon, v6.1.0)
</font>

<br><br><br><br><a href=#top>Go to the top</a>
<B> | </B><a href="keyhr.html#list">Complete list of input variables</a><hr>

<br><font id="title"><a name="dmftctqmc_check">dmftctqmc_check</a></font>
<br><font id="definition">Mnemonics: Dynamical Mean Fied Theory: Continuous Time Quantum Monte Carlo check </font>
<br><font id="category">Characteristic: <a href="../users/abinit_help.html#develop">DEVELOP</a>  </font>
<br><font id="vartype">Variable type: integer  </font>
<br><font id="default">Default is 0  </font>
<br><font id="text">
<p>
<br> 
  Check the fast calculations during the Monte Carlo simulation with very slow but robust methods.
  Should only be used for debugging.
<ul>
<li> 0=&gt;  No check.
<li> 1=&gt;  Check the overlap calculations (Impurity operator).
<li> 2=&gt;  Check the update of M matrix calculation (Bath operator).
<li> 3=&gt;  Check both.
</ul>

</font>

<br><br><br><br><a href=#top>Go to the top</a>
<B> | </B><a href="keyhr.html#list">Complete list of input variables</a><hr>

<br><font id="title"><a name="dmftctqmc_correl">dmftctqmc_correl</a></font>
<br><font id="definition">Mnemonics: Dynamical Mean Fied Theory: Continuous Time Quantum Monte Carlo correlations </font>
<br><font id="category">Characteristic: <a href="../users/abinit_help.html#develop">DEVELOP</a>  </font>
<br><font id="vartype">Variable type: integer  </font>
<br><font id="default">Default is 0  </font>
<br><font id="text">
<p>
<br> Flag to compute statistics about segments and anti-segments during the simulation.
     Slow down the simulation.
<ul>
<li> 0=&gt;  Nothing done
<li> 1=&gt;  Calculations performed and written in "Correlation.dat" file
</ul>

</font>

<br><br><br><br><a href=#top>Go to the top</a>
<B> | </B><a href="keyhr.html#list">Complete list of input variables</a><hr>

<br><font id="title"><a name="dmftctqmc_gmove">dmftctqmc_gmove</a></font>
<br><font id="definition">Mnemonics: Dynamical Mean Fied Theory: Continuous Time Quantum Monte Carlo global moves </font>
<br><font id="category">Characteristic: <a href="../users/abinit_help.html#develop">DEVELOP</a>  </font>
<br><font id="vartype">Variable type: integer  </font>
<br><font id="default">Default is 0  </font>
<br><font id="text">
<p>
<br> Default is no global moves.
Then the value of this variables is the modulo used to try a global move.
A value of 5000 means that a global move is tried every 5000 Monte Carlo sweep.

</font>

<br><br><br><br><a href=#top>Go to the top</a>
<B> | </B><a href="keyhr.html#list">Complete list of input variables</a><hr>

<br><font id="title"><a name="dmftctqmc_grnns">dmftctqmc_grnns</a></font>
<br><font id="definition">Mnemonics: Dynamical Mean Fied Theory: Continuous Time Quantum Monte Carlo greens </font>
<br><font id="category">Characteristic: <a href="../users/abinit_help.html#develop">DEVELOP</a>  </font>
<br><font id="vartype">Variable type: integer  </font>
<br><font id="default">Default is 0  </font>
<br><font id="text">
<p>
<br> Compute the statistical noise for each time slice of each green function.
     This is a good approximation only if there is enough Monte Carlo sweeps per cpu.
<ul>
<li> 0=&gt;  Nothing
<li> 1=&gt;  Do it and write the noise in the "Gtau.dat" file.
</ul>

</font>

<br><br><br><br><a href=#top>Go to the top</a>
<B> | </B><a href="keyhr.html#list">Complete list of input variables</a><hr>

<br><font id="title"><a name="dmftctqmc_meas">dmftctqmc_meas</a></font>
<br><font id="definition">Mnemonics: Dynamical Mean Fied Theory: Continuous Time Quantum Monte Carlo measurements </font>
<br><font id="category">Characteristic: <a href="../users/abinit_help.html#develop">DEVELOP</a>  </font>
<br><font id="vartype">Variable type: integer  </font>
<br><font id="default">Default is 1  </font>
<br><font id="text">
<p>
<br> The modulo used to measure the interaction energy and the number of electrons.
     Example : 2 means the measure is perform every two sweeps.
</font>

<br><br><br><br><a href=#top>Go to the top</a>
<B> | </B><a href="keyhr.html#list">Complete list of input variables</a><hr>
<br><font id="title"><a name="dmftctqmc_mrka">dmftctqmc_mrka</a></font>
<br><font id="definition">Mnemonics: Dynamical Mean Fied Theory: Continuous Time Quantum Monte Carlo markov analysis </font>
<br><font id="category">Characteristic: <a href="../users/abinit_help.html#develop">DEVELOP</a>  </font>
<br><font id="vartype">Variable type: integer  </font>
<br><font id="default">Default is 0  </font>
<br><font id="text">
<p>
<br> Measure the time evolution of the number of electrons for each orbital and perform a fourier transform.
The result can be plot using the "Markov_id.dat" file

<ul>
<li> 0=&gt;  Nothing
<li> 1=&gt;  Do it and write the noise in the "Markov_id.dat" file.
</ul>
</font>

<br><br><br><br><a href=#top>Go to the top</a>
<B> | </B><a href="keyhr.html#list">Complete list of input variables</a><hr>

<br><font id="title"><a name="dmftctqmc_mov">dmftctqmc_mov</a></font>
<br><font id="definition">Mnemonics: Dynamical Mean Fied Theory: Continuous Time Quantum Monte Carlo movie </font>
<br><font id="category">Characteristic: <a href="../users/abinit_help.html#develop">DEVELOP</a>  </font>
<br><font id="vartype">Variable type: integer  </font>
<br><font id="default">Default is 0  </font>
<br><font id="text">
<p>
<br> Print a latex file per cpu displaying the full simulation.
     This option should only be use with very small number (&st;1000) of Monte Carlo sweeps since it requires a lot of I/O band width.
<ul>
<li> 0=&gt;  Nothing
<li> 1=&gt;  Write the "Movie_id.dat" file.
</ul>

</font>

<br><br><br><br><a href=#top>Go to the top</a>
<B> | </B><a href="keyhr.html#list">Complete list of input variables</a><hr>

<br><font id="title"><a name="dmftctqmc_order">dmftctqmc_order</a></font>
<br><font id="definition">Mnemonics: Dynamical Mean Fied Theory: Continuous Time Quantum Monte Carlo perturbation order </font>
<br><font id="category">Characteristic: <a href="../users/abinit_help.html#develop">DEVELOP</a>  </font>
<br><font id="vartype">Variable type: integer  </font>
<br><font id="default">Default is 0  </font>
<br><font id="text">
<p>
<br> Print a file containing the statistic distribution of the number of segments per orbital.
     The maximal order taken into account is this value : 50 means that we avec the statistic distribution from 0 to 50 segments.
     The result is written in the "Perturbation.dat" file.

</font>

<br><br><br><br><a href=#top>Go to the top</a>
<B> | </B><a href="keyhr.html#list">Complete list of input variables</a><hr>

<br><font id="title"><a name="dmftqmc_l">dmftqmc_l</a></font>
<br><font id="definition">Mnemonics: Dynamical Mean Fied Theory: Quantum Monte Carlo time slices </font>
<br><font id="category">Characteristic: <a href="../users/abinit_help.html#develop">DEVELOP</a>  </font>
<br><font id="vartype">Variable type: integer  </font>
<br><font id="default">Default is 0  </font>
<br><font id="text">
<p>
<br> Number of time slices used to represent the time green function.
     This value should be carefully chosen according to Niquist frequency and the tsmear value.

</font>

<br><br><br><br><a href=#top>Go to the top</a>
<B> | </B><a href="keyhr.html#list">Complete list of input variables</a><hr>

<br><font id="title"><a name="dmftqmc_n">dmftqmc_n</a></font>
<br><font id="definition">Mnemonics: Dynamical Mean Fied Theory: Quantum Monte Carlo sweeps </font>
<br><font id="category">Characteristic: <a href="../users/abinit_help.html#develop">DEVELOP</a>  </font>
<br><font id="vartype">Variable type: double precision  </font>
<br><font id="default">Default is 0.d0 </font>
<br><font id="text">
<p>
<br> Number of Monte Carlo sweeps. Should be at least 10^6.

</font>

<br><br><br><br><a href=#top>Go to the top</a>
<B> | </B><a href="keyhr.html#list">Complete list of input variables</a><hr>

<br><font id="title"><a name="dmftqmc_seed">dmftqmc_seed</a></font>
<br><font id="definition">Mnemonics: Dynamical Mean Fied Theory: Quantum Monte Carlo seed </font>
<br><font id="category">Characteristic: <a href="../users/abinit_help.html#develop">DEVELOP</a>  </font>
<br><font id="vartype">Variable type: integer  </font>
<br><font id="default">Default is <a href="varbas.html#jdtset">jdtset</a></font>
	
<br><font id="text">
<p>
<br> Seed to initilize the random number generator. 
<br> Should not be relevant except for testing purpose.
<br> NOTE : In the CT-QMC (<a href="vardev.html#dmft_solv">dmft_solv</a>=5) is used on many CPUs, each CPU initilizes its random number generator with dmftqmc_seed+rank where rank is the rank of the cpu in the MPI communicator.

</font>

<br><br><br><br><a href=#top>Go to the top</a>
<B> | </B><a href="keyhr.html#list">Complete list of input variables</a><hr>

<br><font id="title"><a name="dmftqmc_therm">dmftqmc_therm</a></font>
<br><font id="definition">Mnemonics: Dynamical Mean Fied Theory: Quantum Monte Carlo thermalization </font>
<br><font id="category">Characteristic: <a href="../users/abinit_help.html#develop">DEVELOP</a>  </font>
<br><font id="vartype">Variable type: integer  </font>
<br><font id="default">Default is 1000  </font>
<br><font id="text">
<p>
<br> Number of Monte Carlo sweeps for the thermalization

</font>

<br><br><br><br><a href=#top>Go to the top</a>
<B> | </B><a href="keyhr.html#list">Complete list of input variables</a><hr>

<br><font id="title"><a name="effmass">effmass</a></font>
<br><font id="definition">Mnemonics: EFFective MASS </font>
<br><font id="category">Characteristic: <a href="../users/abinit_help.html#develop">DEVELOP</a>  </font>
<br><font id="vartype">Variable type: real number  </font>
<br><font id="default">Default is one.</font>
<br><font id="text">
<p>
<br>This parameter allows to change the electron mass, with respect to its
experimental value.
</font>

<br><br><br><br><a href=#top>Go to the top</a>
<B> | </B><a href="keyhr.html#list">Complete list of input variables</a><hr>


<br><font id="title"><a name="eshift">eshift</a></font>
<br><font id="definition">Mnemonics: Energy SHIFT </font>
<br><font id="category">Characteristic: <a href="../users/abinit_help.html#develop">DEVELOP</a>, <a href="../users/abinit_help.html#energy">ENERGY</a>  </font>
<br><font id="vartype">Variable type: real number  </font>
<br><font id="default">Default is zero.</font>
<br><font id="text">
<p>
Used only if <a href="vardev.html#wfoptalg">wfoptalg</a>=3 .
<b>eshift</b> gives the shift of the energy used in the
shifted Hamiltonian squared.
The algorithm will determine eigenvalues and eigenvectors centered
on <b>eshift</b>.
<br>Can be specified in Ha (the default), Ry, eV or Kelvin, since
<b>ecut</b> has the
'<a href="../users/abinit_help.html#dimensions">ENERGY</a>' characteristics.
(1 Ha=27.2113845 eV)
</font>

<br><br><br><br><a href=#top>Go to the top</a>
<B> | </B><a href="keyhr.html#list">Complete list of input variables</a><hr>

<br><font id="title"><a name="exchmix">exchmix</a></font><br>
<br><font id="definition">Mnemonics: EXCHange MIXing</font>
<br><font id="category">Characteristic: <a href="../users/abinit_help.html#develop">DEVELOP</a> </font>
<br><font id="vartype">Variable type: real number </font>
<br><font id="default">Default is 0.25 </font>
<br><font id="text">
<p>
<b>exchmix</b> allows to tune the ratio of exact exchange when
<a href="varpaw.html#useexexch">useexexch</a> is used. The default value of 0.25 corresponds to PBE0.
</font>

<br><br><br><br><a href=#top>Go to the top</a>
<B> | </B><a href="keyhr.html#list">Complete list of input variables</a><hr>

<br><font id="title"><a name="exchn2n3d">exchn2n3d</a></font><br>
<br><font id="definition">Mnemonics: EXCHange N2 and N3 Dimensions</font>
<br><font id="category">Characteristic: <a href="../users/abinit_help.html#develop">DEVELOP</a> </font>
<br><font id="vartype">Variable type: integer parameter </font>
<br><font id="default">Default is 0. </font>
<br><font id="text">
<p>
If <b>exchn2n3d</b> is 1, the internal representation of the FFT arrays
in reciprocal space will be array(n1,n3,n2), where the second and
third dimensions have been switched. This is to allow to be coherent with the
<a href="vardev.html#exchn2n3d">exchn2n3d</a>=4xx FFT treatment.
</font>

<br><br><br><br><a href=#top>Go to the top</a>
<B> | </B><a href="keyhr.html#list">Complete list of input variables</a><hr>


<br><font id="title"><a name="fermie_nest">fermie_nest</a></font>
<br><font id="definition">Mnemonics: FERMI Energy for printing the NESTing function </font>
<br><font id="category">Characteristic:  </font>
<br><font id="vartype">Variable type: real parameter  </font>
<br><font id="default">Default is 0</font>
<br><font id="text">
<p>
This input variable is only effective when <a href="vardev.html#prtnest">prtnest</a>=1. The energy is relative to the calculated fermi energy.
</font>


<br><br><br><br><a href=#top>Go to the top</a>
<B> | </B><a href="keyhr.html#list">Complete list of input variables</a><hr>


<br><font id="title"><a name="fftalg">fftalg</a></font>
<br><font id="definition">Mnemonics: Fast Fourier Transform ALGorithm </font>
<br><font id="category">Characteristic: <a href="../users/abinit_help.html#develop">DEVELOP</a> </font>
<br><font id="vartype">Variable type: integer parameter </font>
<br><font id="default">Default is 112, except for VPP Fujitsu, for which the Default is 111, and for NEC, for which the default is 200. Moreover, if the FFTW3 library has been enabled, the default becomes 312, EXCEPT if <a href="vardev.html#usedmft">usedmft</a> is non-zero for at least one dataset. <br> Finally, If <a href="varpar.html#paral_kgb">paral_kgb</a>=1, <b>fftalg</b> is automatically set to 401, with the hightest precedence.</font>
<br><font id="text">
<p>
This keyword is <b>irrelevant</b> when Fast Fourier Transforms are done using <b>Graphics Processing Units</b> (GPU),
i.e. when <a href="varpar.html#use_gpu_cuda">use_gpu_cuda</a>=1 (in that case, it is ignored).
<br><br>Allows to choose the algorithm
for Fast Fourier Transforms. These have to be used
when applied to wavefunctions (routine fourwf.f),
as well as when
applied to densities and potentials (routine fourdp.f).
Presently, it is the concatenation of three digits,
labelled (A), (B) and (C).
<br>
<br>The first digit (A) is to be chosen among 1, 2, 3 and 4 :
<ul>
<li> 1=&gt; use FFT routines written by S. Goedecker.</li>
<li> 2=&gt; not available anymore 
<li> 3=&gt; use serial or multi-threaded FFTW3 fortran routines (<a href="http://www.fftw.org">http://www.fftw.org</a>).
Currently implemented with <b>fftalg</b>=312.</li>
<li> 4=&gt; use FFT routines written by S. Goedecker, 2002 version, that will
be suited for MPI and OpenMP parallelism.</li>
<li>
5=&gt; use serial or multi-threaded MKL routines 
Currently implemented with <b>fftalg</b>=512.</li>

</ul>
The second digit (B) is related to fourdp.f :
<ul>
<li> 0=&gt; only use Complex-to-complex FFT</li>
<li> 1=&gt; real-to-complex is also allowed (only coded for A==1)</li>
</ul>
The third digit (C) is related to fourwf.f :
<ul>
<li> 0=&gt; no use of zero padding </li>
<li> 1=&gt; use of zero padding (only coded for A==1 and A==4)</li>
<li> 2=&gt; use of zero padding, and also combines actual
      FFT operations (using 2 routines from S. Goedecker)
      with important pre- and post-processing
      operations, in order to maximize cache data reuse.
      This is very efficient for cache architectures.
      (coded for A==1 and A==4, but A==4 is not yet sufficiently tested)</li>
</ul>
Internal representation as <a href="vargs.html#ngfft">ngfft</a>(7).</font>

<br><br><br><br><a href=#top>Go to the top</a>
<B> | </B><a href="keyhr.html#list">Complete list of input variables</a><hr>



<br><font id="title"><a name="fftcache">fftcache</a></font><br>
<br><font id="definition">Mnemonics: Fast Fourier Transform CACHE size </font>
<br><font id="category">Characteristic: <a href="../users/abinit_help.html#develop">DEVELOP</a> </font>
<br><font id="vartype">Variable type: integer parameter </font>
<br><font id="default">Default is 16. Not yet machine-dependent.</font>
<br><font id="text">
<p>
Gives the cache size of the current
machine, in Kbytes.
<br>Internal representation as <a href="vargs.html#ngfft">ngfft</a>(8).</font>

<br><br><br><br><a href=#top>Go to the top</a>
<B> | </B><a href="keyhr.html#list">Complete list of input variables</a><hr>

<br><font id="title"><a name="fft_opt_lob">fft_opt_lob</a></font>
<br><font id="definition">Mnemonics: Fast Fourier Transform parallelisation - OPTion for LOB algorithm </font>
<br><font id="category">Characteristic: <a href="../users/abinit_help.html#develop">DEVELOP</a> </font>
<br><font id="vartype">Variable type: integer </font>
<br><font id="default">Default is 1. If <a href="varpar.html#paral_kgb">paral_kgb</a>=1, default is 2.</font>
<br><font id="text">
<p>
Option for LOB algorithm, used in the band/FFT/k-point parallelisation,
see <a href="varpar.html#npband">npband</a>, <a href="varpar.html#npfft">npfft</a>,
<a href="varpar.html#npkpt">npkpt</a>, and <a href="varpar.html#paral_kgb">paral_kgb</a>.
<ul>
<li> =1 : old implementation </li>
<li> =2 : new implementation : the
calls to getghc are made in parallel on a set of bands
<a href="vardev.html#nbdblock">nbdblock</a> :
the aim is to reduce the number of collective communications. This is
not yet implemented in lobpcgwf. </li>
</ul>
</font>

<br><br><br><br><a href=#top>Go to the top</a>
<B> | </B><a href="keyhr.html#list">Complete list of input variables</a><hr>

<br><font id="title"><a name="freqsusin">freqsusin</a></font><br>
<br><font id="definition">Mnemonics: FREQuencies for the SUSceptibility matrix : the INcrement </font>
<br><font id="category">Characteristic: <a href="../users/abinit_help.html#develop">DEVELOP</a> </font>
<br><font id="vartype">Variable type: real parameter, positive or zero </font>
<br><font id="default">Default is 0.0</font>
<br><font id="text">
<p>
Define, with
<a href="vardev.html#freqsuslo">freqsuslo</a>, the series of imaginary frequencies at which
the susceptibility matrix should be computed.
<br>This is still under development.
</font>

<br><br><br><br><a href=#top>Go to the top</a>
<B> | </B><a href="keyhr.html#list">Complete list of input variables</a><hr>


<br><font id="title"><a name="freqsuslo">freqsuslo</a></font><br>
<br><font id="definition">Mnemonics: FREQuencies for the SUSceptibility matrix : the LOwest frequency </font>
<br><font id="category">Characteristic: <a href="../users/abinit_help.html#develop">DEVELOP</a> </font>
<br><font id="vartype">Variable type: real parameter, positive or zero </font>
<br><font id="default">Default is 0.0</font>
<br><font id="text">
<p>
Define, with
<a href="vardev.html#freqsusin">freqsusin</a>,
the series of imaginary frequencies at which
the susceptibility matrix should be computed.
<br>This is still under development.
</font>


<br><br><br><br><a href=#top>Go to the top</a>
<B> | </B><a href="keyhr.html#list">Complete list of input variables</a><hr>

<br><font id="title"><a name="getgam_eig2nkq">getgam_eig2nkq</a></font>
<br><font id="definition">Mnemonics: GET the GAMma phonon data EIG2NKQ from dataset </font>
<br><font id="category">Characteristic: </font>
<br><font id="vartype">Variable type: integer parameter </font>
<br><font id="default">Default is 0.  </font>
<br><br>
<br><font id="text">
<p>
Only relevant if <a href="varrf.html#ieig2rf">ieig2rf</a> is non-zero, that is, if the user is performing performing second-order eigenvalue calcul
ations using response-functions. Also, relevant only for non-zero wavevectors <a href="vargs.html#qpt">qpt</a>
<br><br>From the electron-phonon matrix elements at some wavevector only, it is not possible to determine the Debye-Wallercontribution : one has to know also the q=Gamma electron-phonon matrix elements.
<br>
The variable <b>getgam_eig2nkq</b> allows to transmit the information about the second-order derivatives of the
eigenvalues for q=Gamma from the dataset where the calculation at Gamma was done, to the datasets
for other wavevectors.
</font>

<br><br><br><br><a href=#top>Go to the top</a>
<B> | </B><a href="keyhr.html#list">Complete list of input variables</a><hr>

<br><font id="title"><a name="getwfkfine">getwfkfine</a></font>
<br><font id="definition">Mnemonics: GET the fine grid wavefunctions from _WFK file </font>
<br><font id="category">Characteristic:  </font>
<br><font id="vartype">Variable type: integer parameter </font>
<br><font id="default">Default is 0.</font>
<br><font id="text">Eventually used when <a href="varbas.html#ndtset">ndtset</a>>0
(in the multi-dataset mode), to indicate
starting wavefunctions, as an alternative to
<a href="vardev.html#irdwfkfine">irdwfkfine</a>. One should first read the
explanations given for these latter variables.
<br>
The <b>getwfkfine</b> variables is typically used to chain the calculations 
in the multi-dataset mode, since they describe from which dataset the OUTPUT
wavefunctions are to be taken, as INPUT wavefunctions
of the present dataset.
<br>If <b>getwfkfine</b>==0, no use of previously computed output
wavefunction file appended with _DSx_WFK is done.
<br>If <b>getwfkfine</b> is positive, its value gives the index of the dataset
for which the output wavefunction file appended with _WFK
must be used.
<br>If <b>getwfkfine</b> is -1, the output wf file with _WFK
of the previous dataset must be taken,
which is a frequently occuring case.
<br>If <b>getwfkfine</b> is a negative number, it indicates the number
of datasets to go backward to find the needed wavefunction file.
In this case, if one refers to a non existent data set (prior
to the first), the wavefunctions are not initialised from
a disk file, so that it is as if <b>getwfkfine</b>=0 for that
initialisation.
Thanks to this rule, the use of <b>getwfkfine</b> -1 is rather
straightforward : except for the first wavefunctions, that
are not initialized by reading a disk file, the output
wavefunction of one dataset is input of the next one.
<br>NOTE : a negative value of a "get" variable indicates the number of datasets to go backwards;
it is not the number to be subtracted from the current dataset to find the proper dataset.
As an example : <pre>ndtset 3   jdtset 1 2 4  getXXX -1</pre> refers to dataset 2 when dataset 4 is initialized.

Response-function calculation :
<ul>
<li>one and only one of <b>getwfkfine</b> or <a href="vardev.html#irdwfkfine">irdwfkfine</a> MUST be non-zero</li>
<li>if <b>getwfkfine</b> = 1 : read ground state k -wavefunctions
 from a disk file appended with _WFK , produced in a
 previous ground state calculation (see the
  <a href="../users/abinit_help.html#4">section 4</a> of abinit_help).</li>
<li>Reading the fine grid wavefunction will trigger the k-points interpolation technique of the temperature dependent
calculations. </li>
</ul>

Bethe-Salpeter calculation :
<ul>
<li>one and only one of <b>getwfkfine</b> or <a href="vardev.html#irdwfkfine">irdwfkfine</a> MUST be non-zero</li>
<li>if <b>getwfkfine</b> = 1 : read ground state k -wavefunctions
 from a disk file appended with _WFK , produced in a
 previous ground state calculation (see the
  <a href="../users/abinit_help.html#4">section 4</a> of abinit_help).</li>
<li>This variable or <a href="vardev.html#irdwfkfine">irdwfkfine</a> is mandatory when bs_interp_mode = 1 </li>
</ul>

<b>This variable is experimental. In development.</b>
</font>

<br><br><br><br><a href=#top>Go to the top</a>
<B> | </B><a href="keyhr.html#list">Complete list of input variables</a><hr>

<br><font id="title"><a name="idyson">idyson</a></font>
<br><font id="definition">Mnemonics: Integer giving the choice of method for the DYSON equation</font>
<br><font id="category">Characteristic: <a href="../users/abinit_help.html#develop">DEVELOP</a> </font>
<br><font id="vartype">Variable type: integer parameter </font>
<br><font id="default">Default is 1.</font>
<br><font id="text">
<p>
Choice for the method used to solve the Dyson equation in the calculation
of the interacting susceptibility matrix or/and in the calculation of the ACFD exchange-correlation energy:
<ul>
 <li><b>idyson</b>=1 : Solve the Dyson equation by direct matrix inversion</li>
 <li><b>idyson</b>=2 : Solve the Dyson equation as a first-order differential equation
   with respect to the coupling constant lambda - only implemented for the RPA at the
   present stage (see header of dyson_de.f for details)</li>
 <li><b>idyson</b>=3 : Calculate only the diagonal of the interacting susceptibility matrix
   by self-consistently computing the linear density change in response to a set
   of perturbations. Only implemented for the RPA at the present stage,
   and entirely experimental (see dyson_sc.f for details).</li>
</ul>
</font>

<br><br><br><br><a href=#top>Go to the top</a>
<B> | </B><a href="keyhr.html#list">Complete list of input variables</a><hr>


<br><font id="title"><a name="ikhxc">ikhxc</a></font>
<br><font id="definition">Mnemonics: Integer option for KHXC = Hartree XC kernel </font>
<br><font id="category">Characteristic: </font>
<br><font id="vartype">Variable type: integer parameter </font>
<br><font id="default">Default is 1.</font>
<br><font id="text">
<p>
Define the HXC kernel, in the cases for which it can be
dissociated with the choice of the HXC functional given by
<a href="varbas.html#ixc">ixc</a>, namely the TD-DFT computation of excited
states (<a href="varbas.html#iscf">iscf</a>=-1), and the computation of the
susceptibility matrix (for ACFD purposes). Options 2 to 6 are for the
ACFD only.
<ul>
<li>0 =&gt; RPA for the TDDFT but no kernel for the ACFD (testing purposes).</li>
<li>1 =&gt; RPA for the TDDFT and ACFD.</li>
<li>2 =&gt; ALDA (PW92) for the ACFD</li>
<li>3 =&gt; PGG for the ACFD [M. Petersilka, U.J. Gossmann and E.K.U. Gross, PRL 76,1212 (1996)]</li>
<li>4 =&gt; BPG for the ACFD. This amounts to half the PGG kernel plus half
the ALDA kernel for spin-compensated systems [K. Burke, M. Petersilka and E.K.U. Gross,
in "Recent Advances in Density Functional Methods", Vol. III, edited by P. Fantucci and A. Bencini
(World Scientific, Singapore, 2002)]</li>
<li>5 =&gt; Linear energy optimized kernel [J. Dobson and J. Wang, PRB 62, 10038 (2000)]</li>
<li>6 =&gt; Non-linear energy optimized kernel [J. Dobson and J. Wang, PRB 62, 10038 (2000)]</li>
</ul>
<br>
For ACFD-ALDA, BPG and energy optimized kernels are highly experimental and not tested yet !!!
For ACFD calculations, a cut-off density has been defined for the ALDA, BPG and
energy optimized kernels : let rhomin = userre*rhomax (where rhomax is the maximum density
in space) ; then the actual density used to calculate the local part of these kernels
at point r is max(rho(r),rhomin.
</font>

<br><br><br><br><a href=#top>Go to the top</a>
<B> | </B><a href="keyhr.html#list">Complete list of input variables</a><hr>


<br><font id="title"><a name="intexact">intexact</a></font>
<br><font id="definition">Mnemonics: INTegration using an EXACT scheme </font>
<br><font id="category">Characteristic: <a href="../users/abinit_help.html#develop">DEVELOP</a> </font>
<br><font id="vartype">Variable type: integer parameter </font>
<br><font id="default">Default is 0.</font>
<br><font id="text">
<p>
Relates to the ACFD xc functionals only.
If <b>intexact</b> &gt; 0, the integration over the coupling constant
will be performed analytically in the RPA and in the two-electron PGG
approximation for the ACFD exchange-correlation energy.
Otherwise, the integration over the coupling constant will be performed
numerically (also see
<a href="vardev.html#ndyson">ndyson</a> and
<a href="vardev.html#idyson">idyson</a>.
Note that the program will stop in <b>intexact</b> &gt; 0 and
<a href="vardev.html#ikhxc">ikhxc</a>/=1 (RPA) or
<a href="vardev.html#ikhxc">ikhxc</a>/=3 (PGG, with two electrons)
</font>

<br><br><br><br><a href=#top>Go to the top</a>
<B> | </B><a href="keyhr.html#list">Complete list of input variables</a><hr>


<br><font id="title"><a name="intxc">intxc</a></font>
<br><font id="definition">Mnemonics: INTerpolation for eXchange-Correlation </font>
<br><font id="category">Characteristic: <a href="../users/abinit_help.html#develop">DEVELOP</a> </font>
<br><font id="vartype">Variable type: integer parameter </font>
<br><font id="default">Default is 0.</font>
<br><font id="text">
<p>
<ul>
<li>0=&gt; do "usual" xc quadrature on fft grid</li>
<li>1=&gt; do higher accuracy xc quadrature using fft grid
and additional points at the centers of each cube
(doubles number of grid points)--the high accuracy version
is only valid for boxcut&gt;=2.  If boxcut &lt; 2, the code stops.</li>
</ul>
<br>For RF calculations only <b>intxc</b>=0 is allowed yet. Moreover,
the GS preparation runs (giving the density file and zero-order
wavefunctions) must be done with <b>intxc</b>=0
<p> Prior to ABINITv2.3, the choice <b>intxc</b>=1 was favoured (it was the default),
but the continuation of the development of the code lead to prefer
the default <b>intxc</b>=0 . Indeed, the benefit of <b>intxc</b>=1 is
rather small, while making it available for all cases is a
non-negligible development effort. Other targets are prioritary...
You will notice that many automatice tests use <b>intxc</b>=1. Please,
do not follow this historical choice for your production runs.
</font>

<br><br><br><br><a href=#top>Go to the top</a>
<B> | </B><a href="keyhr.html#list">Complete list of input variables</a><hr>


<br><font id="title"><a name="etsfgroups">etsfgroups</a></font>
<br><font id="definition">Mnemonics: ETSF I/O additional GROUPS of variables</font>
<br><font id="category">Characteristic: <a href="../users/abinit_help.html#develop">DEVELOP</a> </font>
<br><font id="vartype">Variable type: integer parameter </font>
<br><font id="default">Default is 0.</font>
<br><font id="text">
<p>NOTE : NOT USED AT PRESENT (v5.3.0)
<p>This variable is a bit-wise combination of what will be written
into&nbsp;/&nbsp;read from a special WFK/DEN/POT file. The contents of the file
follow the <a href="http://www.etsf.eu/fileformats">Nanoquanta/ETSF file format specifications</a>.</p>
<p>Please check the "etsf_io" module of the ETSF I/O library for possible
values.</p>
</font>

<br><br><br><br><a href=#top>Go to the top</a>
<B> | </B><a href="keyhr.html#list">Complete list of input variables</a><hr>


<br><font id="title"><a name="etsfmain">etsfmain</a></font>
<br><font id="definition">Mnemonics: ETSF I/O MAIN variable</font>
<br><font id="category">Characteristic: <a href="../users/abinit_help.html#develop">DEVELOP</a> </font>
<br><font id="vartype">Variable type: integer parameter </font>
<br><font id="default">Default is 0.</font>
<br><font id="text">
<p>NOTE : NOT USED AT PRESENT (v5.3.0)
<p>This variable tells what will be written into&nbsp;/&nbsp;read from a
special WFK/DEN/POT file. The contents of the file follow the
<a href="http://www.etsf.eu/fileformats">Nanoquanta/ETSF file format specifications</a>.</p>
<p>Please check the "etsf_io" module of the ETSF I/O library for possible
values.</p>
</font>

<br><br><br><br><a href=#top>Go to the top</a>
<B> | </B><a href="keyhr.html#list">Complete list of input variables</a><hr>


<br><font id="title"><a name="iprcch">iprcch</a></font><br>
<br><font id="definition">Mnemonics: Integer for PReConditioning of CHarge response </font>
<br><font id="category">Characteristic: <a href="../users/abinit_help.html#develop">DEVELOP</a> </font>
<br><font id="vartype">Variable type: integer parameter </font>
<br><font id="default">Default is 2.If <a href="varrlx.html#ionmov">ionmov</a>=4 and <a href="varbas.html#iscf">iscf</a>=5,<b>iprcch</b> is automatically put to 3. If <a href="varpar.html#paral_kgb">paral_kgb</a>=1, <b>iprcch</b> is automatically put to 6.</font>
<br><font id="text">
<p>
Used when <a href="varbas.html#iscf">iscf</a>>0, to define:<br>
- the way a change of density is derived from a change of atomic position,<br>
- the way forces are corrected when the SCF cycle is not converged.<br>
<br>Supported values :
<ul>
<li>0 =&gt; density not changed (fixed charge), forces not corrected </li>
<li>1 =&gt; density not changed, forces corrected with rigid ion hypothesis (atomic charge moved with atom)</li>
<li>2 =&gt; density changed and forces corrected with rigid ion hypothesis (atomic charge moves with atom)</li>
<li>3 =&gt; density changed and forces corrected with a different implementation of the rigid ion hypothesis</li>
<li>4 =&gt; density not changed, forces corrected with the use of Harris functional formula (*)</li>
<li>5 =&gt; density changed using D. Alfe 2nd-order algorithm (**), forces not corrected</li>
<li>6 =&gt; density changed using D. Alfe 2nd-order algorithm (**) and forces corrected with the use of Harris functional formula (*)</li>
</ul>
No meaning for RF calculations.<br>

<br>For the time being,<br>
- the choice 3 must be used with <a href="varrlx.html#ionmov">ionmov</a>=4
and <a href="varbas.html#iscf">iscf</a>=5.<br>
- the choices 4, 5 or 6 must be used when band-FFT parallelism is selected.<br>
Otherwise, use the choice 2.<br>

<br><b>(*)</b><U>Note concerning the use of <b>iprcch</b>=4 or 6 (correction of forces)</U>:<br>
The force on the atom located at R is corrected by the addition of the following term:<br>
<i>F_residual=Int[dr.V_residual.dRho_atomic/dR]</i>,  where Rho_atomic is an atomic (spherical) density.<br>
- When such an atomic density (Rho_atomic) is found in the pseudopotential or PAW file, it is used. If not, a gaussian density
 (defined by <a href="vardev.html#densty">densty</a> parameter) is used.<br>
- When SCF mixing is done on the density (<a href="varbas.html#iscf">iscf</a>>=10), the potential residual (V_residual)
is obtained from the density residual with the first order formula <i>V_residual=dV/drho.Rho_residual</i>
 and uses the exchange-correlation kernel <i>dVxc/drho=Kxc</i> which computation is time-consuming for GGA functionals.
By default the LDA exchange-correlation kernel is used (even for GGA, for which it seems to give a reasonable accuracy).
Using the exact GGA exchange correlation kernel is always possible by giving a negative value to <b>iprcch</b>.

<br><br><b>(**)</b><U>Note concerning the use of <b>iprcch</b>=5 or 6 (density prediction)</U>:<br>
The algorithm is described in <i>Computer Physics Communications <b>118</b> (1999) 31-33</i>.
It uses an atomic (spherical) density. When such an atomic density is found in the pseudopotential or PAW file, it is used. If not, a gaussian density
 (defined by <a href="vardev.html#densty">densty</a> parameter) is used.<br>
Also note that, to be efficient, this algorithm requires a minimum convergency of the SCF cycle;
Typically, vres2 (or nres2) has to be small enough (10<sup>-4</sup>...10<sup>-5</sup>).</font>


<br><br><br><br><a href=#top>Go to the top</a>
<B> | </B><a href="keyhr.html#list">Complete list of input variables</a><hr>


<br><font id="title"><a name="iprcfc">iprcfc</a></font>
<br><font id="definition">Mnemonics: Integer for PReConditioner of Force Constants </font>
<br><font id="category">Characteristic: <a href="../users/abinit_help.html#develop">DEVELOP</a> </font>
<br><font id="vartype">Variable type: integer parameter </font>
<br><font id="default">Default is 0.</font>
<br><font id="text">
<p>
Used when <a href="varbas.html#iscf">iscf</a>>0, to define the SCF preconditioning scheme.
Potential-based preconditioning schemes for the SCF loop
are still under development.
<br>The present parameter (force constant part)
describes the way a change of force
is derived from a change of atomic position.
<br>Supported values :
<ul>
<li>0 =&gt; hessian is the identity matrix</li>
<li>1 =&gt; hessian is 0.5 times the identity matrix</li>
<li>2 =&gt; hessian is 0.25 times the identity matrix</li>
<li>-1=&gt; hessian is twice the identity matrix</li>
<li>... (simply corresponding power of 2 times the identity matrix)</li>
</ul>
No meaning for RF calculations.</font>


<br><br><br><br><a href=#top>Go to the top</a>
<B> | </B><a href="keyhr.html#list">Complete list of input variables</a><hr>


<br><font id="title"><a name="irandom">irandom</a></font>
<br><font id="definition">Mnemonics: Integer for the choice of the RANDOM number generator</font>
<br><font id="category">Characteristic: <a href="../users/abinit_help.html#develop">DEVELOP</a> </font>
<br><font id="vartype">Variable type: integer parameter </font>
<br><font id="default">Default is 3.</font>
<br><br>
<br><font id="text">
<p>
For the time being, only used when <a href="varrlx.html#imgmov">imgmov</a>=9
(Langevin Path-Integral Molecular Dynamics).<br>
<b>irandom</b> defines the random number generator.<br>
<br>Supported values :
<ul>
<li>1 =&gt; "uniformrandom", delivered with ABINIT package (initially comes from numerical receipies).</li>
<li>2 =&gt; intrinsic Fortran 90 random number generator.</li>
<li>3 =&gt; "ZBQ" non-deterministic random number generator by R. Chandler and P. Northrop.
(This was delivered for free at http://www.ucl.ac.uk/~ucakarc/work/index.html#code", but
the latter address does not seem to work anymore. In any case, the initial copyright is not violated
by the files/documentation present in the ABINIT package).
</li>
</ul>
<b>irandom</b>=3 is strongly adviced when performing Molecular Dynamics restarts (avoids bias).
</font>

<br><br><br><br><a href=#top>Go to the top</a>
<B> | </B><a href="keyhr.html#list">Complete list of input variables</a><hr>

<br><font id="title"><a name="irdwfkfine">irdwfkfine</a></font>
<br><font id="definition">Mnemonics: Integer that governs the ReaDing of the fine grid _WFK files </font>
<br><font id="category">Characteristic:  </font>
<br><font id="vartype">Variable type: integer parameter </font>
<br><font id="default">Default is 0.</font>
<br><font id="text">Indicates eventual starting
wavefunctions. As alternative, one can use the
input variables <a href="vardev.html#getwfkfine">getwfkfine</a>.
<br>
<br>Ground-state calculation :
<ul>
<li>only <b>irdwfkfine</b> and <a href="vardev.html#getwfkfine">getwfkfine</a> have a meaning</li>
<li>at most one of <b>irdwfkfine</b> or <a href="vardev.html#getwfkfine">getwfkfine</a> can be non-zero</li>
<li>if <b>irdwfkfine</b> = 1 : read ground state wavefunctions
 from a disk file appended with _WFK , produced in a
 previous ground state fine grid calculation (see the
  <a href="../users/abinit_help.html#4">section 4</a> of abinit_help).</li>
</ul>
Response-function calculation :
<ul>
<li>one and only one of <b>irdwfkfine</b> or <a href="vardev.html#getwfkfine">getwfkfine</a> MUST be non-zero</li>
<li>if <b>irdwfkfine</b> = 1 : read ground state k -wavefunctions
 from a disk file appended with _WFK , produced in a
 previous ground state calculation (see the
  <a href="../users/abinit_help.html#4">section 4</a> of abinit_help).</li>
<li>Reading the fine grid wavefunction will trigger the k-points interpolation technique of the temperature dependent
calculations. </li>
</ul>

Bethe-Salpeter calculation :
<ul>
<li>one and only one of <b>irdwfkfine</b> or <a href="vardev.html#getwfkfine">getwfkfine</a> MUST be non-zero</li>
<li>if <b>irdwfkfine</b> = 1 : read ground state k -wavefunctions
 from a disk file appended with _WFK , produced in a
 previous ground state calculation (see the
  <a href="../users/abinit_help.html#4">section 4</a> of abinit_help).</li>
<li>This variable or <a href="vardev.html#getwfkfine">getwfkfine</a> is mandatory when bs_interp_mode = 1</li>
</ul>

<b>This variable is experimental. In development.</b>
</font>


<br><br><br><br><a href=#top>Go to the top</a>
<B> | </B><a href="keyhr.html#list">Complete list of input variables</a><hr>


<font id="title"><a name="irdvdw">irdvdw</a></font>
<br><font id="definition">Mnemonics: Integer that governs the ReaDing of _VDW files</font>
<br><font id="category">Characteristic: <a href="../users/abinit_help.html#develop">DEVELOP</a> </font>
<br><font id="vartype">Variable type: integer parameter </font>
<br><font id="default">Default is 0.</font>
<br><br><font id="text">Used when <a href="vardev.html#vdw_xc">vdw_xc</a>&gt;0,
to read previously calculated vdW-DF variables.<br/>
Supported values:
<ul>
  <li>0 =&gt; do not read vdW-DF variables</li>
  <li>1 =&gt; read vdW-DF variables</li>
</ul>
</font>


<br><br><br><br><a href=#top>Go to the top</a>
<B> | </B><a href="keyhr.html#list">Complete list of input variables</a><hr>


<br><font id="title"><a name="isecur">isecur</a></font>
<br><font id="definition">Mnemonics: Integer for level of SECURity choice </font>
<br><font id="category">Characteristic: <a href="../users/abinit_help.html#develop">DEVELOP</a> </font>
<br><font id="vartype">Variable type: integer </font>
<br><font id="default">Default is 0. </font>
<br><font id="text">
<p>
In the presently used algorithms, there is a compromise
between speed and robustness, that can be tuned by
using <b>isecur</b>.
<br>If <b>isecur</b> =0, an extrapolation of out-of-line
 data is allowed, and might save one non-SCF calculation every
 two line minimisation when some stability conditions
 are fulfilled (since there are 2 non-SCF calculations
 per line minimisation, 1 out of 4 is saved)
<br>Using <b>isecur</b>=1 or higher integers will raise gradually
the threshold to make extrapolation.
<br>Using <b>isecur</b>=-2 will allow to save 2 non-SCF calculations
 every three line minimisation, but this can make the
 algorithm unstable. Lower values of <b>isecur</b> allows
 for more (tentative) savings. In any case, there must
 be one non-SCF computation per line minimisation.
<br>No meaning for RF calculations yet.  </font>

<br><br><br><br><a href=#top>Go to the top</a>
<B> | </B><a href="keyhr.html#list">Complete list of input variables</a><hr>


<br><font id="title"><a name="istatr">istatr</a></font>
<br><font id="definition">Mnemonics: Integer for STATus file repetition Rate </font>
<p>
<br><font id="title"><a name="istatshft">istatshft</a></font>
<br><font id="definition">Mnemonics: Integer for STATus file SHiFT</font>
<p><br><font id="category">Characteristic: <a href="../users/abinit_help.html#develop">DEVELOP</a>, <a href="../users/abinit_help.html#no_multi">NO_MULTI</a> </font>
<br><font id="vartype">Variable type: integer parameter </font>
<br><font id="default">Default is 49, and 149 for Cray T3E (slow I/Os).Values lower than 10 may not work on some machines. Default <b>istatshft</b> is 1.</font>
<br><font id="text">
<p>
Govern the rate of output of the status file.
This status file is written when the number of the
call to the status
subroutine is equal to '<b>istatshft</b>' modulo '<b>istatr</b>', so that
it is written once every '<b>istatr</b>' call.
There is also a writing for each of the 5 first calls,
and the 10th call.</font>

<br><br><br><br><a href=#top>Go to the top</a>
<B> | </B><a href="keyhr.html#list">Complete list of input variables</a><hr>


<br><font id="title"><a name="istwfk">istwfk</a></font>
<br><font id="definition">Mnemonics: Integer for choice of STorage of WaveFunction at each k point </font>
<br><font id="category">Characteristic:  </font>
<br><font id="vartype">Variable type: integer array istwfk(<a href="varbas.html#nkpt">nkpt</a>)  </font>
<br><font id="default">Default is 0 for all k points for GS calculations. For RF calculations, the Default is not used : <b>istwfk</b> is forced to be 1 deep inside the code, for all k points. For spin-orbit calculations (<a href="vargs.html#nspinor">nspinor</a>=2), <b>istwfk</b> is also forced to be 1, for all k points.</font>
<br><font id="text">
<p>
Control the way the
wavefunction for each k-point is stored inside ABINIT,
in reciprocal space.
<br>For the GS calculations, in the "cg" array containing the
wavefunction coefficients, there is for each k-point
and each band, a segment cg(1:2,1:npw). The 'full' number
of plane wave is determined by <a href="varbas.html#ecut">ecut</a>.
However, if the k-point coordinates are build
only from zeroes and halves (see list below),
the use of time-reversal symmetry (that connects coefficients)
has been implemented, in order to use real-to-complex
FFTs (see <a href="vardev.html#fftalg">fftalg</a>), and to treat explicitly only half
of the number of plane waves (this being used as 'npw').
<br>For the RF calculations, there is not only the "cg"
array, but also the "cgq" and "cg1" arrays. For the
time-reversal symmetry to decrease the number of
plane waves of these arrays, the q vector MUST be (0 0 0).
Then, for each k point, the same rule as for the
RF can be applied.
<br>WARNING (991018) : for the time being, the time-reversal
symmetry cannot be used in the RF calculations.
<ul>
<li>1=&gt; do NOT take advantage of the time-reversal symmetry</li>
<li>2=&gt; use time-reversal symmetry for k=( 0   0   0 )</li>
<li>3=&gt; use time-reversal symmetry for k=(1/2  0   0 )</li>
<li>4=&gt; use time-reversal symmetry for k=( 0   0  1/2)</li>
<li>5=&gt; use time-reversal symmetry for k=(1/2  0  1/2)</li>
<li>6=&gt; use time-reversal symmetry for k=( 0  1/2  0 )</li>
<li>7=&gt; use time-reversal symmetry for k=(1/2 1/2  0 )</li>
<li>8=&gt; use time-reversal symmetry for k=( 0  1/2 1/2)</li>
<li>9=&gt; use time-reversal symmetry for k=(1/2 1/2 1/2)</li>
<li>0=&gt; (preprocessed) for each k point, choose automatically
      the appropriate time-reversal option when it is allowed,
      and chose <b>istwfk</b>=1 for all the other k points.</li>
</ul>
Note that the input variable "<a href="varfil.html#mkmem">mkmem</a>" also controls
the wavefunction storage, but at the
level of core memory versus disk space.</font>

<br><br><br><br><a href=#top>Go to the top</a>
<B> | </B><a href="keyhr.html#list">Complete list of input variables</a><hr>


<br><font id="title"><a name="ldgapp">ldgapp</a></font>
<br><font id="definition">Mnemonics: Lein-Dobson-Gross approximation</font>
<br><font id="category">Characteristic: <a href="../users/abinit_help.html#develop">DEVELOP</a>  </font>
<br><font id="vartype">Variable type: integer parameter  </font>
<br><font id="default">Default is 0.</font>
<br><font id="text">
<p>Concern only the ACFD computation of the correlation energy
(<a href="vargs.html#optdriver">optdriver</a>=3).
<br>If <b>ldgapp</b> &gt; 0, the Lein, Dobson and Gross first-order
approximation to the correlation energy is also computed during the ACFD run.
[See Lein, Dobson and Gross, J. Comput. Chem. 20,12 (1999)]. This
is only implemented for the RPA, for the PGG kernel and
for the linear energy optimized kernel at the present time.
</font>

<br><br><br><br><a href=#top>Go to the top</a>
<B> | </B><a href="keyhr.html#list">Complete list of input variables</a><hr>


<br><font id="title"><a name="lotf_classic">lotf_classic</a></font><br>
<br><font id="definition">Mnemonics: LOTF classic model for Glue model </font>
<br><font id="category">Characteristic: <a href="../users/abinit_help.html#develop">DEVELOP</a> </font>
<br><font id="vartype">Variable type: integer parameter  </font>
<br><font id="default">Default is 5.</font>
<br><font id="text">
<p>
Glue model used in LOTF.<br>
For the moment it is imposed to be 5.
</font>

<br><br><br><br><a href=#top>Go to the top</a>
<B> | </B><a href="keyhr.html#list">Complete list of input variables</a><hr>

<br><font id="title"><a name="lotf_nitex">lotf_nitex</a></font><br>
<br><font id="definition">Mnemonics: LOTF number of iterations </font>
<br><font id="category">Characteristic: <a href="../users/abinit_help.html#develop">DEVELOP</a> </font>
<br><font id="vartype">Variable type: integer parameter  </font>
<br><font id="default">Default is 10.</font>
<br><font id="text">
<p>
Set the number of Molecular Dynamics iterations which are computed by LOTF.
</font>

<br><br><br><br><a href=#top>Go to the top</a>
<B> | </B><a href="keyhr.html#list">Complete list of input variables</a><hr>

<br><font id="title"><a name="lotf_nneigx">lotf_nneigx</a></font><br>
<br><font id="definition">Mnemonics: LOTF max number of neighbours </font>
<br><font id="category">Characteristic: <a href="../users/abinit_help.html#develop">DEVELOP</a> </font>
<br><font id="vartype">Variable type: integer parameter  </font>
<br><font id="default">Default is 5.</font>
<br><font id="text">
<p>
Set the max number of Neighbours used in the LOTF method.<br>
For the moment it is imposed to be 40.
</font>

<br><br><br><br><a href=#top>Go to the top</a>
<B> | </B><a href="keyhr.html#list">Complete list of input variables</a><hr>

<br><font id="title"><a name="lotf_version">lotf_version</a></font><br>
<br><font id="definition">Mnemonics: LOTF version of MD algorithm </font>
<br><font id="category">Characteristic: <a href="../users/abinit_help.html#develop">DEVELOP</a> </font>
<br><font id="vartype">Variable type: integer parameter  </font>
<br><font id="default">Default is 2.</font>
<br><font id="text">
<p>
Set the MD algorithm in the LOTF method.<br>
For the moment it is imposed to be 2.
</font>

<br><br><br><br><a href=#top>Go to the top</a>
<B> | </B><a href="keyhr.html#list">Complete list of input variables</a><hr>


<br><font id="title"><a name="macro_uj">macro_uj</a></font>
<br><font id="definition">Mnemonics: Macro variable that activates the determination of the U and J parameter (for the PAW+U calculations) </font>
<br><font id="category">Characteristic: <a href="../users/abinit_help.html#develop">DEVELOP</a>  </font>
<br><font id="vartype">Variable type: integer parameter  </font>
<br><font id="default">Default is 0.</font>
<br><font id="text">
<p>Sets proper input values for the determination of U and J i.e.
for <a href="vardev.html#pawujat">pawujat</a> (first atom treated with PAW+U),
<a href="varfil.html#irdwfk">irdwfk</a> (=1),
<a href="varbas.html#tolvrs">tolvrs</a> (=10^(-8)),
<a href="varbas.html#nstep">nstep</a> (=255),
<a href="vargs.html#diemix">diemix</a> (=0.45),
<a href="varff.html#atvshift">atvshift</a> (<a href="vardev.html#pawujat">pawujat</a>) <a href="vardev.html#pawujv">pawujv</a>). Do not overwrite these variables manually unless you know what you do.

<ul>
<li> <b>macro_uj</b>=1 (and <a href="varbas.html#nsppol">nsppol</a>=2) Standard procedure to determine U on atom pawujat through a shift of the potential on both spin channels.</li>
<li> <b>macro_uj</b>=1 (and <a href="varbas.html#nsppol">nsppol</a>=1) Non standand procedure to determine U from potential shift on atom pawujat (experimental).</li>
<li> <b>macro_uj</b>=2 (and <a href="varbas.html#nsppol">nsppol</a>=2) Non standand procedure to determine U from potential shift on atom pawujat through a shift on spin channel 1 on this atom and the response on this channel (experimental).</li>
<li> <b>macro_uj</b>=3 (and <a href="varbas.html#nsppol">nsppol</a>=2) Standand procedure to determine J from potential shift on spin channel 1 on atom pawujat and response on spin channel 2 (experimental).</li>
</ul>

Determination of U and J can be done only if the symmetry of the atomic arrangement is reduced and the atom pawujat is not connected to any other atom by symmetry relations (either input reduced symmetries manually, define concerned atom as a separate atomic species or shift concerned atom from ideal postion).

</font>

<br><br><br><br><a href=#top>Go to the top</a>
<B> | </B><a href="keyhr.html#list">Complete list of input variables</a><hr>



<br><font id="title"><a name="maxnsym">maxnsym</a></font>
<br><font id="definition">Mnemonics: MAXimum Number of SYMetries</font>
<br><font id="category">Characteristic: <a href="../users/abinit_help.html#develop">DEVELOP</a>  </font>
<br><font id="vartype">Variable type: integer parameter  </font>
<br><font id="default">Default is 384.</font>
<br><font id="text">
<p>Gives the maximum number of spatial symetries allowed in the memory.<br>
The default value is sufficient for most applications; it has to be increase in the case of the use of a supercell (unit cell identically repeated).
</font>

<br><br><br><br><a href=#top>Go to the top</a>
<B> | </B><a href="keyhr.html#list">Complete list of input variables</a><hr>


<br><font id="title"><a name="mem_test">mem_test</a></font>
<br><font id="definition">Mnemonics: MEMory TEST</font>
<br><font id="category">Characteristic: <a href="../users/abinit_help.html#develop">DEVELOP</a>  </font>
<br><font id="vartype">Variable type: integer parameter  </font>
<br><font id="default">Default is 1.</font>
<br><font id="text">
<p>
This variable controls the memory test done in the memana routine.
Possible values:
<ul>
<li>
0 no test on the available memory is performed
</li>
<li>
1 the routine tries to allocate the estimated memory, for testing
  purposes, and if a failure occurs, the routine stops.
</li>
<li>
2 like 1, but before stopping, the routine will provide
  an estimation of the available memory.
</li>
</ul>
</font>


<br><br><br><br><a href=#top>Go to the top</a>
<B> | </B><a href="keyhr.html#list">Complete list of input variables</a><hr>


<br><font id="title"><a name="mqgrid">mqgrid</a></font>
<br><font id="definition">Mnemonics: Maximum number of Q-space GRID points for pseudopotentials</font>
<br><font id="category">Characteristic: <a href="../users/abinit_help.html#develop">DEVELOP</a>  </font>
<br><font id="vartype">Variable type: integer parameter  </font>
<br><font id="default">Default is 3001.</font>
<br><font id="text">
<p>Govern the size of the one-dimensional information
related to pseudopotentials, in reciprocal space :
potentials, or projector functions.
</font>


<br><br><br><br><a href=#top>Go to the top</a>
<B> | </B><a href="keyhr.html#list">Complete list of input variables</a><hr>


<br><font id="title"><a name="nbandsus">nbandsus</a></font>
<br><font id="definition">Mnemonics: Number of BANDs to compute the SUSceptibility </font>
<br><font id="category">Characteristic: </font>
<br><font id="vartype">Variable type: integer parameter </font>
<br><font id="default">Default is <a href="varbas.html#nband">nband</a>.</font>
<br><font id="text">
<p>
Number of bands to be used in the calculation of the susceptibility matrix (ACFD only).
</font>


<br><br><br><br><a href=#top>Go to the top</a>
<B> | </B><a href="keyhr.html#list">Complete list of input variables</a><hr>


<br><font id="title"><a name="nbdblock">nbdblock</a></font>
<br><font id="definition">Mnemonics: Number of BanDs in a BLOCK </font>
<br><font id="category">Characteristic: <a href="../users/abinit_help.html#develop">DEVELOP</a>  </font>
<br><font id="vartype">Variable type: integer parameter  </font>
<br><font id="default">Default is 1</font>
<br><font id="text">
<p>In case of non-standard, blocked algorithms for the
optimization of the wavefunctions (that is, if
 <a href="vardev.html#wfoptalg">wfoptalg</a>=4):
<ul>
<li>if <a href="vardev.html#wfoptalg">wfoptalg</a>=4,
<b>nbdblock</b> defines the number of blocks (the number of bands in the block is
then <a href="varbas.html#nband">nband</a>/nbdblock ).</li>
</ul>
</font>


<br><br><br><br><a href=#top>Go to the top</a>
<B> | </B><a href="keyhr.html#list">Complete list of input variables</a><hr>


<br><font id="title"><a name="nctime">nctime</a></font>
<br><font id="definition">Mnemonics: NetCdf TIME between output of molecular dynamics informations </font>
<br><font id="category">Characteristic: <a href="../users/abinit_help.html#develop">DEVELOP</a>  </font>
<br><font id="vartype">Variable type: integer parameter  </font>
<br><font id="default">Default is 0</font>
<br><font id="text">
<p>When <b>nctime</b> is non-zero, the molecular dynamics information
is output in NetCDF format, every <b>nctime</b> time step. Here is the content of an example file :
<pre>
netcdf md32.outH_moldyn1 {
dimensions:
        time = UNLIMITED ; // (11 currently)
        DimTensor = 6 ;
        DimCoord = 3 ;
        NbAtoms = 32 ;
        DimVector = 3 ;
        DimScalar = 1 ;
variables:
        double E_pot(time) ;
                E_pot:units = "hartree" ;
        double E_kin(time) ;
                E_kin:units = "hartree" ;
        double Stress(time, DimTensor) ;
                Stress:units = "hartree/Bohr^3" ;
        double Position(time, DimCoord, NbAtoms) ;
                Position:units = "Bohr" ;
        double Celerity(time, DimCoord, NbAtoms) ;
                Celerity:units = "Bohr/(atomic time unit)" ;
        double PrimitiveVector1(DimVector) ;
        double PrimitiveVector2(DimVector) ;
        double PrimitiveVector3(DimVector) ;
        double Cell_Volume(DimScalar) ;
                Cell_Volume:units = "Bohr^3" ;
}
</pre>

</font>


<br><br><br><br><a href=#top>Go to the top</a>
<B> | </B><a href="keyhr.html#list">Complete list of input variables</a><hr>



<br><font id="title"><a name="ndyson">ndyson</a></font>
<br><font id="definition">Mnemonics: Number of points to be added for the solution of the DYSON equation </font>
<br><font id="category">Characteristic: </font>
<br><font id="vartype">Variable type: integer parameter </font>
<br><font id="default">Default is -1.</font>
<br><font id="text">
<p>
Number of points to be added to lambda=0 and lambda=1 (that are always calculated
for the integration ober the coupling constant lambda in the ACFD calculation of the
exchange-correlation energy.
<ul>
<li>ndyson=-1 : let the code decide how many points to use (presently, 3 points
for <a href="vardev.html#idyson">idyson</a>=1 or 3, and 9 points for
<a href="vardev.html#idyson">idyson</a>=2)</li>
<li>ndyson=0 : only compute the non-interacting and fully-interacting
susceptibility matrices.</li>
<li>ndyson&gt;0 : use <b>ndyson</b> more points in ]0,1[</li>
</ul>
</font>



<br><br><br><br><a href=#top>Go to the top</a>
<B> | </B><a href="keyhr.html#list">Complete list of input variables</a><hr>


<br><font id="title"><a name="nfreqsus">nfreqsus</a></font>
<br><font id="definition">Mnemonics: Number of FREQuencies for the SUSceptibility matrix</font>
<br><font id="category">Characteristic: <a href="../users/abinit_help.html#develop">DEVELOP</a>  </font>
<br><font id="vartype">Variable type: integer parameter  </font>
<br><font id="default">Default is 0</font>
<br><font id="text">
<p>
If 0, no computation of frequency-dependent susceptibility matrix.
If 1 or larger, will read <a href="vardev.html#freqsuslo">freqsuslo</a> and
<a href="vardev.html#freqsusin">freqsusin</a>
to define the frequencies
(1 is currently the only value allowed)
</font>

<br><br><br><br><a href=#top>Go to the top</a>
<B> | </B><a href="keyhr.html#list">Complete list of input variables</a><hr>


<br><font id="title"><a name="nloalg">nloalg</a></font>
<br><font id="definition">Mnemonics: Non Local ALGorithm </font>
<br><font id="category">Characteristic: <a href="../users/abinit_help.html#develop">DEVELOP</a> </font>
<br><font id="vartype">Variable type: integer variable  </font>
<br><font id="default">Default is 4 (norm-conserving psps) or 14 (PAW), except for the NEC where it is 2 (or 12).</font>
<br><font id="text">
<p>
Allows to choose the algorithm
for non-local operator application.
On super-scalar architectures, the Default <b>nloalg</b>=4/14 is the best,
but you can save memory by using <b>nloalg</b>=-4.<br>
More detailed explanations:<br><br>
<div style="margin-left: 10px;">Units figure of <b>nloalg</b>:</div>
<div style="margin-left: 40px;">
- <b>nloalg</b>=?2 : Should be efficient on vector machines. It is
indeed the fastest algorithm for the NEC, but
 actual tests on Fujitsu machine did not gave better
 performances than the other options.<br>
- <b>nloalg</b>=?3 : same as <b>nloalg</b>==2, but the loop order is inverted.<br>
- <b>nloalg</b>=?4 : same as <b>nloalg</b>==3, but maximal use of registers
 has been coded. This should be especially efficient on
 scalar and super-scalar machines. This has been
 confirmed by tests.<br>
</div><br>
<div style="margin-left: 10px;">Tens figure of <b>nloalg</b>:</div>
<div style="margin-left: 40px;">
- <b>nloalg</b><10 : (k+G) vectors are not precomputed, in order to save memory space.<br>
- <b>nloalg</b>>=10 : (k+G) vectors are precomputed, once per k-point.<br>
</div><br>
<div style="margin-left: 10px;">Sign of <b>nloalg</b>:</div>
<div style="margin-left: 40px;">
Negative values of <b>nloalg</b> correspond positive ones,
where the phase precomputation has been suppressed,
in order to save memory space: an array <i>double precision :: ph3d(2,npw,<a href="varbas.html#natom">natom</a>)</i>
is saved (typically half the space needed
for the wavefunctions at 1 k point - this corresponds
to the silicon case). However, the computation of phases
inside nonlop is somehow time-consuming.<br>
</div>
<br>
Note: internally, <b>nloalg</b> is an array <i>nloalg(1:5)</i>,
that also allows to initialize several internal variables (not documented):
<div style="margin-left: 40px;">
- <i>nloalg(1)</i>=mod(<b>nloalg</b>,10)<br>
- <i>jump</i>=nloalg(2)<br>
- <i>mblkpw</i>=nloalg(3)<br>
- <i>mincat</i>=nloalg(4)<br>
- <i>nloalg(5)</i>=<b>nloalg</b>/10<br>
</div>
However, only <i>nloalg(1)+10*nloalg(5)</i> is read as an input variable.</font>

<br><br><br><br><a href=#top>Go to the top</a>
<B> | </B><a href="keyhr.html#list">Complete list of input variables</a><hr>


<br><font id="title"><a name="nnsclo">nnsclo</a></font>
<br><font id="definition">Mnemonics: Number of Non-Self Consistent LOops </font>
<br><font id="category">Characteristic: <a href="../users/abinit_help.html#develop">DEVELOP</a> </font>
<br><font id="vartype">Variable type: integer parameter </font>
<br><font id="default">Default is 0.</font>
<br><font id="text"> 
<p>
Gives the maximum number of
non-self-consistent loops of <a href="vargs.html#nline">nline</a> line minimisations,
in the SCF case (when <a href="varbas.html#iscf">iscf</a> &gt;0).  In the case <a href="varbas.html#iscf">iscf</a> &lt;=0 ,
the number of non-self-consistent loops is determined
by <a href="varbas.html#nstep">nstep</a>.
<br>The Default value of 0 correspond to make
the two first fixed potential determinations
of wavefunctions have 2 non-self consistent loops,
and the next ones to have only 1 non-self consistent loop. </font>


<br><br><br><br><a href=#top>Go to the top</a>
<B> | </B><a href="keyhr.html#list">Complete list of input variables</a><hr>

<br><font id="title"><a name="nnsclohf">nnsclohf</a></font>
<br><font id="definition">Mnemonics: Number of Non-Self Consistent LOops for Fock exact exchange</font>
<br><font id="category">Characteristic: <a href="../users/abinit_help.html#develop">DEVELOP</a> </font>
<br><font id="vartype">Variable type: integer parameter </font>
<br><font id="default">Default is 0 if <a href="varint.html#usefock">usefock</a> &lt;=0, and 1 if <a href="varint.html#usefock">usefock</a> &lt;=1.</font>
<br><font id="text"> 
<p>
Gives the maximum number of loops with non-self-consistent occupied states used to calculate Fock exact exchange,
in the SCF case.  
<br>The Default value is 0 when <a href="varint.html#usefock">usefock</a> &lt;=0.
Default value is 1 when <a href="varint.html#usefock">usefock</a> &lt;=1 and correspond to update occupied 
wavefunctions at each self-consistent loop. </font>


<br><br><br><br><a href=#top>Go to the top</a>
<B> | </B><a href="keyhr.html#list">Complete list of input variables</a><hr>


<br><font id="title"><a name="normpawu">normpawu</a></font><br>
<br><font id="definition">Mnemonics: NORMalize atomic PAW+U projector </font>
<br><font id="category">Characteristic: <a href="../users/abinit_help.html#develop">DEVELOP</a> </font>
<br><font id="vartype">Variable type: integer normpawu(<a href="varbas.html#ntypat">ntypat</a>) </font>
<br><font id="default">Default is 0 </font>
<br><font id="text">
<p>
Defines whether the atomic wave function (used as projectors in PAW+U) should be renormalized to 1
within PAW sphere.
<ul>
 <li><b>normpawu</b>=0 : leave projector</li>
 <li><b>normpawu</b>=1 : renormalize </li>
</ul>
</font>


<br><br><br><br><a href=#top>Go to the top</a>
<B> | </B><a href="keyhr.html#list">Complete list of input variables</a><hr>

<br><font id="title"><a name="noseft">noseft</a></font>
<br><font id="definition">Mnemonics: </font>
<br><font id="category">Characteristic:  </font>
<br><font id="vartype">Variable type: </font>
<br><font id="default">Default is </font>
<br><font id="text">
<p>
TO BE DOCUMENTED
</font>

<br><br><br><br><a href=#top>Go to the top</a>
<B> | </B><a href="keyhr.html#list">Complete list of input variables</a><hr>

<br><font id="title"><a name="noseinert">noseinert</a></font>
<br><font id="definition">Mnemonics: </font>
<br><font id="category">Characteristic:  </font>
<br><font id="vartype">Variable type: </font>
<br><font id="default">Default is </font>
<br><font id="text">
<p>
TO BE DOCUMENTED
</font>

<br><br><br><br><a href=#top>Go to the top</a>
<B> | </B><a href="keyhr.html#list">Complete list of input variables</a><hr>

<br><font id="title"><a name="npulayit">npulayit</a></font>
<br><font id="definition">Mnemonics: Number of PULAY ITerations for SC mixing </font>
<br><font id="category">Characteristic: <a href="../users/abinit_help.html#develop">DEVELOP</a> </font>
<br><font id="vartype">Variable type: integer parameter </font>
<br><font id="default">Default is 7.</font>
<br><font id="text">
<p>
Needed only when
<a href="varbas.html#iscf">iscf</a>=7 or 17.
<br><font id="text">
<p>
 Gives the  number of previous iterations involved in Pulay mixing (mixing
during electronic SC iterations).
</font>

<br><br><br><br><a href=#top>Go to the top</a>
<B> | </B><a href="keyhr.html#list">Complete list of input variables</a><hr>

<br><font id="title"><a name="nscforder">nscforder</a></font>
<br><font id="definition">Mnemonics: SCaling Function ORDER</font>
<br><font id="category">Characteristic:  </font>
<br><font id="vartype">Variable type: </font>
<br><font id="default">Default is 16</font>
<br><font id="text">
<p>
This variable controls the order of used scaling functions when the Hartree potential is computed using the Poisson solver (see <a href="vargs.html#icoulomb">icoulomb</a> imput variable). This variable is of seldom use since the default value is large enough. Nonetheless, possible values are 8, 14, 16, 20, 24, 30, 40, 50, 60, 100. Values greater than 20 are included in ABINIT for test purposes only.
</font>

<br><br><br><br><a href=#top>Go to the top</a>
<B> | </B><a href="keyhr.html#list">Complete list of input variables</a><hr>

<br><font id="title"><a name="optforces">optforces</a></font>
<br><font id="definition">Mnemonics: OPTions for the calculation of FORCES </font>
<br><font id="category">Characteristic: <a href="../users/abinit_help.html#develop">DEVELOP</a>  </font>
<br><font id="vartype">Variable type: integer parameter  </font>
<br><font id="default">Default is 2. However, <b>optforces</b> is automatically set to 1 when <a href="varbas.html#toldff">toldff</a> or <a href="varbas.html#tolrff">tolrff</a> are non-zero.</font>
<br><font id="text">
<p>
 Allows to choose options for the calculation of forces.
<ul>
 <li><b>optforces</b>=0 : the forces are set to zero, and many steps of the
   computation of forces are skipped </li>
 <li><b>optforces</b>=1 : calculation of forces at each SCF iteration, allowing
   to use forces as criterion to stop the SCF cycles
   </li>
 <li><b>optforces</b>=2 : calculation of forces at the end of the SCF iterations
   (like the stresses)
   </li>
</ul>
</font>

<br><br><br><br><a href=#top>Go to the top</a>
<B> | </B><a href="keyhr.html#list">Complete list of input variables</a><hr>

<br><font id="title"><a name="optfreqsus">optfreqsus</a></font>
<br><font id="definition">Mnemonics: OPTion for the generation of FREQuency grids for the SUSceptibility</font>
<br><font id="category">Characteristic: <a href="../users/abinit_help.html#develop">DEVELOP</a></font>
<br><font id="vartype">Variable type: integer parameter</font>
<br><font id="default">Default is 2</font>
<br><font id="text">
<p>
Selects the type of frequency grid that will be used to compute ACFD energies,
as follows:
</p>
<ul>
 <li>0: use preassigned mesh (see defs_suscep module)
  <ul>
   <li>nfreqsus= 2: pick-up 2 highest frequencies of H_2 mesh</li>
   <li>nfreqsus= 8: pick-up 8 frequencies inside Be_2 mesh, depending on freq1</li>
   <li>nfreqsus= 9: pick-up 9 frequencies inside H_2 mesh, depending on freq1</li>
   <li>nfreqsus=11: pick-up 11 highest frequencies of Be_2 mesh</li>
   <li>nfreqsus=16: use full He mesh</li>
   <li>nfreqsus=18: use full H_2 mesh</li>
   <li>nfreqsus=20: use full He mesh good up to 8 Ha</li>
   <li>nfreqsus=24: use full Be_2 mesh</li>
  </ul>
 </li>
 <li>1: create linear mesh and weights for quadrature by Taylor rule
  <ul>
   <li>freqsusin=starting frequency</li>
   <li>freqsuslo=frequency increment</li>
  </ul>
 </li>
 <li>2: create mesh and weights using Gauss-Legendre quadrature
  <p>A first Gauss-Legendre mesh is built for interval [0,freqsuslo], then
    a second one is obtained by transforming the first for the
    [freqsuslo,+\infty[ interval. freqsusin may be use to compress or expand
    the mesh on the second interval (a value of 1.0 is adequate for
    most cases). For practical reasons, nfreqsus must be even.
  </p>
 </li>
</ul>

<p>
See also:
<a href="vardev.html#nfreqsus">nfreqsus</a>,
<a href="vardev.html#freqsuslo">freqsuslo</a>,
<a href="vardev.html#freqsusin">freqsusin</a>.
</p>

</font>


<br><br><br><br><a href=#top>Go to the top</a>
<B> | </B><a href="keyhr.html#list">Complete list of input variables</a><hr>


<br><font id="title"><a name="optnlxccc">optnlxccc</a></font>
<br><font id="definition">Mnemonics: OPTion for the calculation of Non-Linear eXchange-Correlation Core Correction</font>
<br><font id="category">Characteristic: <a href="../users/abinit_help.html#develop">DEVELOP</a>  </font>
<br><font id="vartype">Variable type: integer parameter  </font>
<br><font id="default">Default is 1.</font>
<br><font id="text">
<p>
Allows to choose options for the calculation of non-linear XC correction.
At present, only relevant for the FHI type of pseudopotentials, with pspcod=6 .
<ul>
 <li><b>optnlxccc</b>=1 : uses the old psp6cc.f routine, with inconsistent treatment of real-space derivatives of the core function (computed in this routine, while splined in the other parts of the code) </li>
 <li><b>optnlxccc</b>=2 : consistent calculation derivatives, in the psp6cc_dhr.f routine from DHamann.</li>
</ul>
</font>


<br><br><br><br><a href=#top>Go to the top</a>
<B> | </B><a href="keyhr.html#list">Complete list of input variables</a><hr>


<br><font id="title"><a name="ortalg">ortalg</a></font>
<br><font id="definition">Mnemonics: ORThogonalisation ALGorithm </font>
<br><font id="category">Characteristic: <a href="../users/abinit_help.html#develop">DEVELOP</a>  </font>
<br><font id="vartype">Variable type: integer parameter  </font>
<br><font id="default">Default is 2 when <a href="vardev.html#wfoptalg">wfoptalg</a> &lt; 10,<br> -2 when <a href="vardev.html#wfoptalg">wfoptalg</a> >=10.</font>
<br><font id="text">
<p> Allows to choose the algorithm
for orthogonalisation.
<br>Positive or zero values make two projections per
line minimisation, one before the preconditioning, one
after. This is the clean application of the band-by-band
CG gradient for finding eigenfunctions.
<br>Negative values make only one projection per line mininisation.
<br>The orthogonalisation step is twice faster, but the
convergence is less good. This actually calls to
a better understanding of this effect.
<br><b>ortalg</b>=0, 1 or -1 is the conventional coding, actually
 identical to the one in versions prior to 1.7
<br><b>ortalg</b>=2 or -2 try to make better use of existing registers
on the particular machine one is running.
<br>More demanding use of registers
is provided by <b>ortalg</b>=3 or -3, and so on.
<br>The maximal value is presently 4 and -4.
<br>Tests have shown that <b>ortalg</b>=2 or -2 is suitable for
use on the available platforms.</font>

<br><br><br><br><a href=#top>Go to the top</a>
<B> | </B><a href="keyhr.html#list">Complete list of input variables</a><hr>

<br><font id="title"><a name="papiopt">papiopt</a></font>
<br><font id="definition">Mnemonics: PAPI OPTion</font>
<br><font id="category">Characteristic:  </font>
<br><font id="vartype">Variable type: integer</font>
<br><font id="default">Default is 0 </font>
<br><font id="text">
<p>
	<a href="http://icl.cs.utk.edu/papi/index.html">PAPI</a> aims to
	provide the tool designer and application engineer with a
	consistent interface and methodology for use of the
	performance counter hardware found in most major
	microprocessors. PAPI enables software engineers to see, in
	near real time, the relation between software performance and
	processor events.<br />

	This option can be used only when ABINIT has been compiled with the
	<code>--enable-papi</code> configure option.<br />

	If <b>papiopt</b>=1, then PAPI counters are used instead of
	the usual time() routine. All the timing output of ABINIT is
	then done with PAPI values. The measurements are more accurate and
	give also access to the flops of the calculation.
</font>

<br><br><br><br><a href=#top>Go to the top</a>
<B> | </B><a href="keyhr.html#list">Complete list of input variables</a><hr>

<br><font id="title"><a name="pawprt_b">pawprt_b</a></font>
<br><font id="definition">Mnemonics: PAW print band</font>
<br><font id="category">Characteristic:  DEVELOP </font>
<br><font id="vartype">Variable type: integer</font>
<br><font id="default">Default is 0 </font>
<br><font id="text">
<p>
	Forces the output of the all-electron wavefunction for
	only a single band. To be used in conjuction with:<b><br />
	<a href="varpaw.html#pawprtwf">pawprtwf</a>=1</b> and
	<a href="vardev.html#pawprt_k">pawprt_k</a>.
	The indexing of the bands start with one for the lowest occupied band
	and goes up from there.
</font>

<br><br><br><br><a href=#top>Go to the top</a>
<B> | </B><a href="keyhr.html#list">Complete list of input variables</a><hr>

<br><font id="title"><a name="pawprt_k">pawprt_k</a></font>
<br><font id="definition">Mnemonics: PAW print k-point</font>
<br><font id="category">Characteristic: DEVELOP</font>
<br><font id="vartype">Variable type: integer</font>
<br><font id="default">Default is 0 </font>
<br><font id="text">
<p>
	Forces the output of the all-electron wavefunction for
	only a single k-point. To be used in conjuction with:<b><br />
	<a href="varpaw.html#pawprtwf">pawprtwf</a>=1</b> and
	<a href="vardev.html#pawprt_b">pawprt_b</a>.
	The indexing follows the order in ouptput of the internal
	variable <b>kpt</b> in the beginning of the run.
</font>


<br><br><br><br><a href=#top>Go to the top</a>
<B> | </B><a href="keyhr.html#list">Complete list of input variables</a><hr>

<br><font id="title"><a name="pawujat">pawujat</a></font>
<br><font id="definition">Mnemonics: PAW+macro_UJ, ATom number </font>
<br><font id="category">Characteristic: <a href="../users/abinit_help.html#develop">DEVELOP</a></font>
<br><font id="vartype">Variable type: integer</font>
<br><font id="default">Default is 1, i.e. the first atom treated with PAW+U. </font>
<br><font id="text">
<p>
Determines the atom for which U (or J) should be determined. See also <a href="vardev.html#macro_uj">macro_uj</a>.
</font>


<br><br><br><br><a href=#top>Go to the top</a>
<B> | </B><a href="keyhr.html#list">Complete list of input variables</a><hr>

<br><font id="title"><a name="pawujrad">pawujrad</a></font>
<br><font id="definition">Mnemonics: PAW+macro_UJ, sphere RADius</font>
<br><font id="category">Characteristic: <a href="../users/abinit_help.html#develop">DEVELOP</a></font>
<br><font id="vartype">Variable type: real </font>
<b>pawujrad</b> has the
'<a href="../users/abinit_help.html#dimensions">LENGTH</a>' characteristics.
<br><font id="default">Default is 20 a.u. </font>
<br><font id="text">
<p>
The sphere radius serves to extrapolate the U value calculated at r_paw to a larger sphere radius.
See also <a href="vardev.html#macro_uj">macro_uj</a>.
As most projector functions are localized within r_paw to &asymp;80%,
20 a.u. contains &asymp;100% of the wavefunction and corresponds to r_paw &rarr; &infin;.
</font>

<br><br><br><br><a href=#top>Go to the top</a>
<B> | </B><a href="keyhr.html#list">Complete list of input variables</a><hr>

<br><font id="title"><a name="pawujv">pawujv</a></font>
<br><font id="definition">Mnemonics: PAW+macro_UJ, potential shift (V)</font>
<br><font id="category">Characteristic: <a href="../users/abinit_help.html#develop">DEVELOP</a></font>
<br><font id="vartype">Variable type: real,  </font>
<b>pawujv</b> has the
'<a href="../users/abinit_help.html#dimensions">ENERGY</a>' characteristics.
<br><font id="default">Default is 0.1 eV. </font>
<br><font id="text">
<p>
Amplitude of the potential shift for the determination of U (or J). See also <a href="vardev.html#macro_uj">macro_uj</a>.
</font>

<br><br><br><br><a href=#top>Go to the top</a>
<B> | </B><a href="keyhr.html#list">Complete list of input variables</a><hr>

<br><font id="title"><a name="plowan_bandf">plowan_bandf</a></font>
<br><font id="definition">Mnemonics: Projected Local Orbital WANnier functions Initial BAND  </font>
<br><font id="category">Characteristic: <a href="../users/abinit_help.html#develop">DEVELOP</a></font>
<br><font id="vartype">Variable type: integer,  </font>
<br><font id="default">Default is 0 . </font>
<br><font id="text">
<p>
<br>  Gives the upper band to include in the calculation of Wannier functions
</font>

<br><br><br><br><a href=#top>Go to the top</a>
<B> | </B><a href="keyhr.html#list">Complete list of input variables</a><hr>

<br><font id="title"><a name="plowan_bandi">plowan_bandi</a></font>
<br><font id="definition">Mnemonics: Projected Local Orbital WANnier functions Initial BAND  </font>
<br><font id="category">Characteristic: <a href="../users/abinit_help.html#develop">DEVELOP</a></font>
<br><font id="vartype">Variable type: integer,  </font>
<br><font id="default">Default is 0 . </font>
<br><font id="text">
<p>
<br>  Gives the lower band to include in the calculation of Wannier functions
</font>

<br><br><br><br><a href=#top>Go to the top</a>
<B> | </B><a href="keyhr.html#list">Complete list of input variables</a><hr>

<br><font id="title"><a name="plowan_compute">plowan_compute</a></font>
<br><font id="definition">Mnemonics: Projected Local Orbital WANnier functions COMPUTATION </font>
<br><font id="category">Characteristic: <a href="../users/abinit_help.html#develop">DEVELOP</a></font>
<br><font id="vartype">Variable type: integer,  </font>
<br><font id="default">Default is 0 . </font>
<br><font id="text">
<p>
<br> Activate computation of Projected Local Orbital Wannier functions (PLO Wannier) and  corresponding band structure.
Variables	<a href="vardev.html#plowan_bandi">plowan_bandi</a>,
<a href="vardev.html#plowan_bandf">plowan_bandf</a>,
<a href="vardev.html#plowan_natom">plowan_natom</a>,
<a href="vardev.html#plowan_nbl">plowan_nbl</a>,
<a href="vardev.html#plowan_iatom">plowan_iatom</a>,
<a href="vardev.html#plowan_lcalc">plowan_lcalc</a>,
<a href="vardev.html#plowan_projcalc">plowan_projcalc</a> are mandatory to precise the nature of the projections.
<ul>
<li> 0=&gt; Default value: do not activate calculation of PLO Wannier.
<li> 1=&gt; Compute PLO Wannier and band structure
<li> 2=&gt; Compute PLO Wannier and band structure. In this case, the coupling in k-space between blocks of Wannier functions belonging to different
angular momenta or atoms is removed.
</ul>

Other related variables are
<a href="vardev.html#plowan_realspace">plowan_realspace</a>,
<a href="vardev.html#plowan_nt">plowan_nt</a>,
<a href="vardev.html#plowan_it">plowan_it</a>.

The implementation is not symetrized over k-point and not parallelized.

(The calculation of projections is 
detailed in <a href="http://journals.aps.org/prb/abstract/10.1103/PhysRevB.77.205112"> Phys. Rev. B 77, 205112, (2008)</a>) 
</font>

<br><br><br><br><a href=#top>Go to the top</a>
<B> | </B><a href="keyhr.html#list">Complete list of input variables</a><hr>

<br><font id="title"><a name="plowan_iatom">plowan_iatom</a></font>
<br><font id="definition">Mnemonics: Projected Local Orbital WANnier functions,  ATOM Index  </font>
<br><font id="category">Characteristic: <a href="../users/abinit_help.html#develop">DEVELOP</a></font>
<br><font id="vartype">Variable type: integer,  </font>
<br><font id="default">Default is 0 . </font>
<br><font id="text">
<p>
<br>  Gives the <a href="vardev.html#plowan_natom">plowan_natom</a>, atoms on which the projections will be done.
</font>
<br><br><br><br><a href=#top>Go to the top</a>

<B> | </B><a href="keyhr.html#list">Complete list of input variables</a><hr>
<br><font id="title"><a name="plowan_it">plowan_it</a></font>
<br><font id="definition">Mnemonics: Projected Local Orbital WANnier functions,  Index of Translation.</font>
<br><font id="category">Characteristic: <a href="../users/abinit_help.html#develop">DEVELOP</a></font>
<br><font id="vartype">Variable type: integer array plowan_it(plowan_nt*3) </font>
<br><font id="default">Default is 0 . </font>
<br><font id="text">
<p>
<br>  Requires <a href="vardev.html#plowan_realspace">plowan_realspace</a>  to be greater than 0 and
<a href="vardev.html#plowan_nt">plowan_nt</a>  to be greater than 0.
Precise a given set of selected real space translation by using the real space vectors basis. 
These atoms are used to define Wannier functions in real space. These real space
Wannier functions are used as a basis to compute the Hamiltonian.
</font>

<br><br><br><br><a href=#top>Go to the top</a>
<B> | </B><a href="keyhr.html#list">Complete list of input variables</a><hr>

<br><font id="title"><a name="plowan_lcalc">plowan_lcalc</a></font>
<br><font id="definition">Mnemonics: Projected Local Orbital WANnier functions,  L values to use for CALCulation  </font>
<br><font id="category">Characteristic: <a href="../users/abinit_help.html#develop">DEVELOP</a></font>
<br><font id="vartype">Variable type: integer array plowan_lcalc(\sum_plowan_natom plowan_nbl(iatom)) </font>
<br><font id="default">Default is -1 . </font>
<br><font id="text">
<p>
<br>  Gives the <a href="vardev.html#plowan_nbl">plowan_nbl</a> values of angular momenta for each atom, in the order of the atoms
as given in <a href="vardev.html#plowan_iatom">plowan_iatom</a>.
</font>

<br><br><br><br><a href=#top>Go to the top</a>
<B> | </B><a href="keyhr.html#list">Complete list of input variables</a><hr>

<br><font id="title"><a name="plowan_natom">plowan_natom</a></font>
<br><font id="definition">Mnemonics: Projected Local Orbital WANnier functions, Number of ATOMs  </font>
<br><font id="category">Characteristic: <a href="../users/abinit_help.html#develop">DEVELOP</a></font>
<br><font id="vartype">Variable type: integer,  </font>
<br><font id="default">Default is 0 . </font>
<br><font id="text">
<p>
<br>  Gives the number of atoms on which the projection will be done
</font>

<br><br><br><br><a href=#top>Go to the top</a>
<B> | </B><a href="keyhr.html#list">Complete list of input variables</a><hr>

<br><font id="title"><a name="plowan_nbl">plowan_nbl</a></font>
<br><font id="definition">Mnemonics: Projected Local Orbital WANnier functions,  NumBer of L values  </font>
<br><font id="category">Characteristic: <a href="../users/abinit_help.html#develop">DEVELOP</a></font>
<br><font id="vartype">Variable type: integer array plowan_nbl(plowan_natom) </font>
<br><font id="default">Default is 0 . </font>
<br><font id="text">
<p>
<br>  Gives the total number of angular momenta (over all atoms) to compute the projections.
</font>

<br><br><br><br><a href=#top>Go to the top</a>
<B> | </B><a href="keyhr.html#list">Complete list of input variables</a><hr>

<br><font id="title"><a name="plowan_nt">plowan_nt</a></font>
<br><font id="definition">Mnemonics: Projected Local Orbital WANnier functions,  Number of Translation on which the real space values of
energy is computed</font>
<br><font id="category">Characteristic: <a href="../users/abinit_help.html#develop">DEVELOP</a></font>
<br><font id="vartype">Variable type: integer,  </font>
<br><font id="default">Default is 0 . </font>
<br><font id="text">
<p>
<br>  Requires <a href="vardev.html#plowan_realspace">plowan_realspace</a>  to be greater than 0.  
Gives a number of selected atoms. These atoms are used to define Wannier functions in real space. These real space
Wannier functions are used as a basis to compute the Hamiltonian.
</font>

<br><br><br><br><a href=#top>Go to the top</a>
<B> | </B><a href="keyhr.html#list">Complete list of input variables</a><hr>

<br><font id="title"><a name="plowan_projcalc">plowan_projcalc</a></font>
<br><font id="definition">Mnemonics: Projected Local Orbital WANnier functions,  PROJectors values to use for CALCulation  </font>
<br><font id="category">Characteristic: <a href="../users/abinit_help.html#develop">DEVELOP</a></font>
<br><font id="vartype">Variable type: integer array plowan_projcalc(\sum_plowan_natom plowan_nbl(iatom)) </font>
<br><font id="default">Default is -1 . </font>
<br><font id="text">
<p>
<br>  Gives the <a href="vardev.html#plowan_nbl">plowan_nbl</a> values of projectors for each atom, in the order of the atoms
as given in <a href="vardev.html#plowan_iatom">plowan_iatom</a>. The index i for the projectors refers to the  ith number on line
orbitals of the PAW atomic data file.
</font>

<br><br><br><br><a href=#top>Go to the top</a>
<B> | </B><a href="keyhr.html#list">Complete list of input variables</a><hr>

<br><font id="title"><a name="plowan_realspace">plowan_realspace</a></font>
<br><font id="definition">Mnemonics: Projected Local Orbital WANnier functions,  activate REAL SPACE calculation.</font>
<br><font id="category">Characteristic: <a href="../users/abinit_help.html#develop">DEVELOP</a></font>
<br><font id="vartype">Variable type: integer </font>
<br><font id="default">Default is 0. </font>
<br><font id="text">
<p> Can take the following values:
<ul>
<li> 0=&gt; Default value: do not activate calculation of real space Wannier functions.
<li> 1=&gt; Compute PLO Wannier in real space for analysis. These data can also be used in a following data set to perform a Wannier interpolation.
<li> 2=&gt; Do simple Wannier Interpolation for a given k points starting from real space Wannier function Hamiltonian
computed in a preceding dataset.
</ul>
</font>

<br><br><br><br><a href=#top>Go to the top</a>
<B> | </B><a href="keyhr.html#list">Complete list of input variables</a><hr>

<br><font id="title"><a name="prepscphon">prepscphon</a></font>
<br><font id="definition">Mnemonics: PREPare Self-Consistent PHONon calculation</font>
<br><font id="category">Characteristic: <a href="../users/abinit_help.html#develop">DEVELOP</a></font>
<br><font id="vartype">Variable type: integer</font>
<br><font id="default">Default is 0 </font>
<br><font id="text">
<p>
Print PCINFO, PHFREQ, and PHVEC files, for use with self-consistent phonon runs, after a perturbation
calculation. Only prints out files for the present q-point, and there is presently no tool to symmetrize
or merge these files, so use anaddb instead (with prtscphon input variable). The abinit input
variable is destined to someday bypass the use of anaddb for scphon calculations.
</font>
<br><br><br><br><a href=#top>Go to the top</a>
<B> | </B><a href="keyhr.html#list">Complete list of input variables</a><hr>

<br><font id="title"><a name="prtbltztrp">prtbltztrp</a></font>
<br><font id="definition">Mnemonics: PRinT output for BoLTZTRaP code</font>
<br><font id="category">Characteristic: <a href="../users/abinit_help.html#develop">DEVELOP</a></font>
<br><font id="vartype">Variable type: integer</font>
<br><font id="default">Default is 0 </font>
<br><font id="text">
<p>
Print out geometry (_BLZTRP_GEOM) and eigenenergy (_BLZTRP_EIGEN) files for the
<a href="http://www.icams.de/content/departments/atomistic-modelling-and-simulation/simplified-models-of-the-electronic-structure/boltztrap/"> BoltzTraP code</a> by Georg Madsen.
</font>
<br><br><br><br><a href=#top>Go to the top</a>
<B> | </B><a href="keyhr.html#list">Complete list of input variables</a><hr>

<br><font id="title"><a name="prtcif">prtcif</a></font>
<br><font id="definition">Mnemonics: PRinT Crystallographic Information File</font>
<br><font id="category">Characteristic:  DEVELOP</font>
<br><font id="vartype">Variable type: integer flag</font>
<br><font id="default">Default is 0 </font>
<br><font id="text">
<p>
If set to 1, a CIF file is output with the crystallographic data for the present run (cell size shape and atomic positions).
</font>
<br><br><br><br><a href=#top>Go to the top</a>
<B> | </B><a href="keyhr.html#list">Complete list of input variables</a><hr>

<br><font id="title"><a name="prtdipole">prtdipole</a></font>
<br><font id="definition">Mnemonics: PRinT DIPOLE</font>
<br><font id="category">Characteristic: <a href="../users/abinit_help.html#develop">DEVELOP</a></font>
<br><font id="vartype">Variable type: integer</font>
<br><font id="default">Default is 0 </font>
<br><font id="text">
<p>
Print out dipole of unit cell, calculated in real space for the primitive cell only. Under development.
</font>
<br><br><br><br><a href=#top>Go to the top</a>
<B> | </B><a href="keyhr.html#list">Complete list of input variables</a><hr>

<br><font id="title"><a name="prtnest">prtnest</a></font>
<br><font id="definition">Mnemonics: PRinT NESTing function</font>
<br><font id="category">Characteristic:  DEVELOP</font>
<br><font id="vartype">Variable type: integer flag</font>
<br><font id="default">Default is 0 </font>
<br><font id="text">
<p>
If set to 1, the nesting function for the k-point grid is printed. For the moment the path in q space for the nesting function is fixed, but will become an input as well.
</font>
<br><br><br><br><a href=#top>Go to the top</a>
<B> | </B><a href="keyhr.html#list">Complete list of input variables</a><hr>

<br><font id="title"><a name="prtposcar">prtposcar</a></font>
<br><font id="definition">Mnemonics: PRinT POSCAR file</font>
<br><font id="category">Characteristic: <a href="../users/abinit_help.html#develop">DEVELOP</a></font>
<br><font id="vartype">Variable type: integer</font>
<br><font id="default">Default is 0 </font>
<br><font id="text">
<p>
Print out VASP-style POSCAR and FORCES files, for use with PHON or frophon codes for frozen phonon calculations.
See the associated script in ~abinit/extras/post_processing/phondisp2abi.py for further details on interfacing
with PHON, PHONOPY, etc...
</font>
<br><br><br><br><a href=#top>Go to the top</a>
<B> | </B><a href="keyhr.html#list">Complete list of input variables</a><hr>

<font id="title"><a name="prtvdw">prtvdw</a></font>
<br><font id="definition">Mnemonics: PRinT Van Der Waals file</font>
<br><font id="category">Characteristic: <a href="../users/abinit_help.html#develop">DEVELOP</a></font>
<br><font id="vartype">Variable type: integer</font>
<br><font id="default">Default is 0 </font>
<br><br><font id="text">
Print out a NetCDF file containing a vdW-DF kernel.
<!-- See the associated script in
~abinit/extras/post_processing/vdw_check_kernel for further details. -->
</font>
<br><br><br><br><a href=#top>Go to the top</a>
<B> | </B><a href="keyhr.html#list">Complete list of input variables</a><hr>



<br><font id="title"><a name="recefermi">recefermi</a></font>
<br><font id="definition">Mnemonics: RECursion - initial guess  of the FERMI Energy</font>
<br><font id="category">Characteristic: <a href="../users/abinit_help.html#develop">DEVELOP</a>  </font>
<br><font id="vartype">Variable type: real</font>
<br><font id="default">Default is 0</font>
<br><font id="text">
<p>

Used in Recursion method (<a href="vardev.html#tfkinfunc">tfkinfunc</a>=2).
In the first  SCF calculation it fixes the initial guess for the Fermi energy.
</font>

<br><br><br><br><a href=#top>Go to the top</a>
<B> | </B><a href="keyhr.html#list">Complete list of input variables</a><hr>


<br><font id="title"><a name="recgratio">recgratio</a></font>
<br><font id="definition">Mnemonics: RECursion - Grid Ratio </font>
<br><font id="category">Characteristic: <a href="../users/abinit_help.html#develop">DEVELOP</a>  </font>
<br><font id="vartype">Variable type: integer</font>
<br><font id="default">Default is 1</font>
<br><font id="text">
<p>

Used in Recursion method (<a href="vardev.html#tfkinfunc">tfkinfunc</a>=2).
It represents the ratio of the two grid step: <b>recgratio</b>=fine_step/coarse_step and
it is bigger or equal than 1.  It introduces a double-grid system which permits
to compute the electronic density on a coarse grid, using a fine grid
(defined by <a href="vargs.html#ngfft">ngfft</a>) in the
discretisation of the green kernel (see <ahref="vardev.html#recptrott">recptrott</a>).
Successively the density and the recursion coefficients are interpolated on the fine grid by
FFT interpolation.  Note that ngfft/recgratio=number of points of the
coarse grid has to be compatible with the parallelization parameters.
</font>

<br><br><br><br><a href=#top>Go to the top</a>
<B> | </B><a href="keyhr.html#list">Complete list of input variables</a><hr>



<br><font id="title"><a name="recnpath">recnpath</a></font>
<br><font id="definition">Mnemonics: RECursion - Number of point for PATH integral calculations </font>
<br><font id="category">Characteristic: <a href="../users/abinit_help.html#develop">DEVELOP</a>  </font>
<br><font id="vartype">Variable type: integer</font>
<br><font id="default">Default is 500</font>
<br><font id="text">
<p>

Used in Recursion method (<a href="vardev.html#tfkinfunc">tfkinfunc</a>=2).
Determine the number of discretisation points to compute some path
integral in the recursion method ; those path integrals are used to
compute the entropy and the eigenvalues energy. during the latest SFC
cycles. </font>

<br><br><br><br><a href=#top>Go to the top</a>
<B> | </B><a href="keyhr.html#list">Complete list of input variables</a><hr>


<br><font id="title"><a name="recnrec">recnrec</a></font>
<br><font id="definition">Mnemonics: RECursion - Number of RECursions </font>
<br><font id="category">Characteristic: <a href="../users/abinit_help.html#develop">DEVELOP</a>  </font>
<br><font id="vartype">Variable type: integer</font>
<br><font id="default">Default is 10</font>
<br><font id="text">
<p>

Used in Recursion method (<a href="vardev.html#tfkinfunc">tfkinfunc</a>=2).
Determine the maximum order of recursion, that is the dimension of the
krylov space we use to compute density. If the precision setten by
 <a href="vardev.html#rectolden">rectolden</a> is reached before that order, the recursion method
automatically stops.  </font>

<br><br><br><br><a href=#top>Go to the top</a>
<B> | </B><a href="keyhr.html#list">Complete list of input variables</a><hr>



<br><font id="title"><a name="recptrott">recptrott</a></font>
<br><font id="definition">Mnemonics: RECursion - TROTTer P parameter </font>
<br><font id="category">Characteristic: <a href="../users/abinit_help.html#develop">DEVELOP</a>  </font>
<br><font id="vartype">Variable type: integer</font>
<br><font id="default">Default is 0</font>
<br><font id="text">
<p>
Used in Recursion method (<a href="vardev.html#tfkinfunc">tfkinfunc</a>=2).
Determine the trotter parameter used to compute the exponential of the hamiltonian in the
recursion method: exp(-beta*(-Delta + V)) ~ (exp(-beta/(4*recptrott)
V) exp(-beta/(4*recptrott) Delta) exp(-beta/(4*recptrott)
V))^(2*recptrott).
If set to 0, we use recptrott = 1/2 in the above formula.
Increasing <b>recptrott</b> improve the accuracy of the trotter formula, but
increase the dicretisation error: it may be necessary to increase
 <a href="vargs.html#ngfft">ngfft</a>. The discretisation error is essentially the discretisation
error of the green kernel exp((recptrott/beta*|r|^2)) on the ngfft
grid.
</font>

<br><br><br><br><a href=#top>Go to the top</a>
<B> | </B><a href="keyhr.html#list">Complete list of input variables</a><hr>

<br><font id="title"><a name="recrcut">recrcut</a></font>
<br><font id="definition">Mnemonics: RECursion - CUTing Radius  </font>
<br><font id="category">Characteristic: <a href="../users/abinit_help.html#develop">DEVELOP</a>  </font>
<br><font id="vartype">Variable type: integer</font>
<br><font id="default">Default is 0</font>
<br><font id="text">
<p>
Used in Recursion method (<a href="vardev.html#tfkinfunc">tfkinfunc</a>=2).
Used to improve the
computational time in the case of the recursion method in a large
cell: the density at a point will be computed with taking account only of
a sphere of radius <b>recrcut</b>.
</font>

<br><br><br><br><a href=#top>Go to the top</a>
<B> | </B><a href="keyhr.html#list">Complete list of input variables</a><hr>

<br><font id="title"><a name="rectesteg">rectesteg</a></font>
<br><font id="definition">Mnemonics: RECursion - TEST on Electron Gas  </font>
<br><font id="category">Characteristic: <a href="../users/abinit_help.html#develop">DEVELOP</a>  </font>
<br><font id="vartype">Variable type: integer</font>
<br><font id="default">Default is 0</font>
<br><font id="text">
<p>
Used in Recursion method (<a href="vardev.html#tfkinfunc">tfkinfunc</a>=2).
It is used to test an electron gas by putting the ion potential
equal to zero.
</font>

<br><br><br><br><a href=#top>Go to the top</a>
<B> | </B><a href="keyhr.html#list">Complete list of input variables</a><hr>

<br><font id="title"><a name="rectolden">rectolden</a></font>
<br><font id="definition">Mnemonics: RECursion - TOLerance on the difference of electronic DENsity  </font>
<br><font id="category">Characteristic: <a href="../users/abinit_help.html#develop">DEVELOP</a>  </font>
<br><font id="vartype">Variable type: real</font>
<br><font id="default">Default is 0.0E00 (to change)</font>
<br><font id="text">
<p>
Used in Recursion method (<a href="vardev.html#tfkinfunc">tfkinfunc</a>=2).
Sets a tolerance for differences of electronic density that, reached TWICE
successively, will cause one SCF cycle to stop. That electronic
density difference is computed in the infinity norm (that is, it is
computed point-by-point, and then the maximum difference is computed).
</font>


<br><br><br><br><a href=#top>Go to the top</a>
<B> | </B><a href="keyhr.html#list">Complete list of input variables</a><hr>



<br><font id="title"><a name="suskxcrs">suskxcrs</a></font>
<br><font id="definition">Mnemonics: SUSceptibility times KXC treated in real space </font>
<br><font id="category">Characteristic: <a href="../users/abinit_help.html#develop">DEVELOP</a>  </font>
<br><font id="vartype">Variable type: integer</font>
<br><font id="default">Default is 0</font>
<br><font id="text">
<p>
Only relevant for the ACFD calculation of total energies.
If <b>suskxcrs</b>=1, the XC kernel is not treated in
reciprocal space, but combined with the susceptibility (chi_0), to avoid
Kxc divergences where the density goes to zero (G. Onida &amp; M. Gatti !)
<p>
Not applicable for RPA (as there should be a Kxc present). Initially tested for ikhxc==2 (ALDA).
</font>

<br><br><br><br><a href=#top>Go to the top</a>
<B> | </B><a href="keyhr.html#list">Complete list of input variables</a><hr>




<br><font id="title"><a name="symmorphi">symmorphi</a></font>
<br><font id="definition">Mnemonics: SYMMORPHIc symmetry operations </font>
<br><font id="category">Characteristic: <a href="../users/abinit_help.html#develop">DEVELOP</a>, <a href="../users/abinit_help.html#gw">GW</a></font>
<br><font id="vartype">Variable type: integer parameter</font>
<br><font id="default">Default is 1</font>
<br><font id="text">
<p>
With <b>symmorphi</b>=1, symmetry operations with a non-symmorphic vector are allowed.
With <b>symmorphi</b>=0, they are not allowed.
In the latter case, if the symmetry operations are specified in the input file, the code
will stop and print an error message if a non-symmorphic vector is encountered.
By contrast, if the symmetry operations are to be determined automatically
(if <a href="varbas.html#nsym">nsym</a>=0), then the set of symmetries will
not include the non-symmorphic operations.
<p>
Note : this feature exist because in a previous status of the GW calculations, non-symmorphic
symmetry operations could not be exploited. Thus, the k points were restricted
to the IBZ. In order to prepare GW calculations, and to perform GW calculations,
<b>symmorphi</b>=0 was to be used, together with <a href="varbas.html#nsym">nsym</a>=0.
</font>


<br><br><br><br><a href=#top>Go to the top</a>
<B> | </B><a href="keyhr.html#list">Complete list of input variables</a><hr>


<br><font id="title"><a name="tfkinfunc">tfkinfunc</a></font>
<br><font id="definition">Mnemonics: Thomas-Fermi KINetic energy FUNCtional </font>
<br><font id="category">Characteristic: <a href="../users/abinit_help.html#develop">DEVELOP</a>  </font>
<br><font id="vartype">Variable type: integer</font>
<br><font id="default">Default is 0</font>
<br><font id="text">
<p>
<ul>
<li>
 <b>tfkinfunc</b>=1 : Thomas-Fermi
kinetic functional (explicit functional of the density)
is used instead of Kohn-Sham kinetic energy functional (implicit functional of the density
through Kohn-Sham wavefunctions).
<br></li>
<li> <b>tfkinfunc</b>=2 : the Recursion Method is used in order to compute
electronic density, entropy, Fermi energy and eigenvalues energy. This
method computes the density without computing any orbital, is
efficient at high temperature, with a efficient parallelization
(almost perfect scalability). When that option is in use, the
 <a href="varbas.html#ecut">ecut</a> input variable is no longer a
 convergence parameter ;
 <a href="vargs.html#ngfft">ngfft</a> becomes
the main convergence parameter: you should adapt ecut for the ngfft
grid you need (it is not yet automatically computed). Other
convergence parameter are for the energetic values:
 <a href="vardev.html#recnrec">recnrec</a>, <a href="vardev.html#recptrott">recptrott</a>,
 <a href="vardev.html#recnpath">recnpath</a>.
Since the convergence of the self-consistent cycle
is determined directly by the convergence of the density:
<a href="varbas.html#toldfe">toldfe</a>,
 <a href="varbas.html#toldff">toldff</a>
 <a href="varbas.html#tolrff">tolrff</a>,
 <a href="varbas.html#tolvrs">tolvrs</a>,
 <a href="varbas.html#tolwfr">tolwfr</a> are not used, and are replaced by
 <a href="vardev.html#rectolden">rectolden</a>; the energetic values, except for the fermi energy, are only
computed during the latest SFC cycle : the output file will show a
jump of the total energy at the end, but it is not because of a bad
convergence behavior. Computational speed can be improved by the use
of  <a href="vardev.html#recrcut">recrcut</a> and  <a href="vardev.html#recgratio">recgratio</a>.
The recursion method has not be tested in the case of non cubic cell
or with the use of symmetries.
In the recursion method the following variables are set to:
<br> <a href="vardev.html#useylm">useylm</a>=1,
<br> <a href="varint.html#userec">userec</a>=1.
</ul>
</li>
</font>

<br><br><br><br><a href=#top>Go to the top</a>
<B> | </B><a href="keyhr.html#list">Complete list of input variables</a><hr>

<br><font id="title"><a name="tolrde">tolrde</a></font>
<br><font id="definition">Mnemonics: TOLerance on the Relative Difference of Eigenenergies </font>
<br><font id="category">Characteristic:  </font>
<br><font id="vartype">Variable type: real parameter  </font>
<br><font id="default">Default is 0.005</font>
<br><font id="text">
<p>
Sets a tolerance for the ratio of differences of eigenenergies
in the line minisation conjugate-gradient algorithm. It compares the
decrease of the eigenenergy due to the last line minimisation, with the
one observed for the first line minimisation.
When the ratio is lower than <b>tolrde</b>,
the next line minimisations are skipped.
<br>The number of line minimisations is limited by
<a href="vargs.html#nline">nline</a> anyhow.
<br>This stopping criterion is present for both GS and RF calculations.
In RF calculations, <b>tolrde</b> is actually doubled before comparing with the above-mentioned
ratio, for historical reasons.</font>


<br><br><br><br><a href=#top>Go to the top</a>
<B> | </B><a href="keyhr.html#list">Complete list of input variables</a><hr>

<br><font id="title"><a name="usedmft">usedmft</a></font>
<br><font id="definition">Mnemonics: USE Dynamical Mean Field Theory </font>
<br><font id="category">Characteristic: <a href="../users/abinit_help.html#develop">DEVELOP</a>  </font>
<br><font id="vartype">Variable type: integer parameter  </font>
<br><font id="default">Default is 0 </font>
<br><font id="text">
<p>
If set to 1, enable the use of DFT+DMFT, see in particular the important variables
	<a href="vardev.html#dmft_solv">dmft_solv</a>,
	<a href="vardev.html#dmftbandi">dmftbandi</a>,
	<a href="vardev.html#dmftbandf">dmftbandf</a>,
	<a href="vardev.html#dmft_nwli">dmft_nwli</a>,
	<a href="vardev.html#dmft_nwlo">dmft_nwlo</a>,
	<a href="vardev.html#dmft_tollc">dmft_tollc</a>,
	and	<a href="vardev.html#dmft_iter">dmft_iter</a>. </p>

	<p> The current implementation uses Wannier functions obtained from 
<a href="http://journals.aps.org/prb/abstract/10.1103/PhysRevB.77.205112">projected local orbitals</a> as correlated orbitals (see <a href="vardev.html#dmftbandi">dmftbandi</a>  and <a href="vardev.html#dmftbandf">dmftbandf</a> input variables to define them). </p>

	<p> The Green's function are computed on a mesh of linear Matsubara frequencies. However, most of the code uses logarithmic Matsubara grid to lower the computational cost. Both <a href="vardev.html#dmft_nwli">dmft_nwli</a> and <a href="vardev.html#dmft_nwlo">dmft_nwlo</a> are thus convergence parameters. </p>

<p> DMFT is currently available for collinear (nspinor=1) polarized or unpolarized calculations (nspden=nsppol=2 or nspden=nsppol=1)
and for non collinear calculations (nspinor=2,nspden=4,nsppol=1). However it is not yet available
for collinear antiferromagnetic calculations  (nspden=2,nsppol=1) and non collinear non magnetic calculations (nspden=1, nsppol=1,nspinor=2). 
CTQMC calculations (<a href="vardev.html#dmft_solv">dmft_solv</a>=5) are not yet possible if nspinor=2.</p>

<p> Only static calculations without relaxation or dynamics are possible (forces and stress are not computed in the scheme: so the computed values should NOT be trusted).</p>
 
<p> When correlated density matrices are diagonal, all values of  <a href="varpaw.html#upawu">upawu</a> and <a href="varpaw.html#upawu">jpawu</a> are possible. If the correlated density matrices are non diagonal, only <a href="varpaw.html#upawu">jpawu</a>=0 is implemented. </p>

<p> Relevant direct output quantities from
converged DMFT calculations are total energy and occupation of correlated orbitals. For Hubbard I calculation (<a href="vardev.html#dmft_solv">dmft_solv</a>=2), total and partial spectral
functions can be obtained with prtdos=1 and can be found in files OUTSpFunc* (where OUT is the root for
output files). For CTQMC calculations (<a href="vardev.html#dmft_solv">dmft_solv</a>=5), imaginary time impurity Green's function are output of the calculations and can be used to produce
spectral function using an external Maximum Entropy Code. </p>

<p> A typical DFT+DMFT calculation involves two runs. First, a DFT calculation is fully converged (even unoccupied wavefunctions have to be converged).
Then, the DFT+DMFT calculation is started using DFT wavefunctions or density files.  As DFT+DMFT calculations (with CTQMC) are computationnally
expensive, it is convenient to use prtden=-1, to write DEN file at each DFT iteration, in order to be able to restart the calculation easily. </p>



<p>
For details of the implementation see,  
<a href="http://journals.aps.org/prb/abstract/10.1103/PhysRevB.77.205112">B. Amadon, F. Lechermann, A. Georges, F.  Jollet, T. O.  Wehling, and A. I.  Lichtenstein, Phys. Rev. B 77(20), (2008)</a>, for Wannier functions and
<a href="http://iopscience.iop.org/0953-8984/24/7/075604">B. Amadon, J. Phys.: Condens. Matter 24 075604 (2012)</a>, 
for self-consistency and Hubbard I implementation.

If usedmft=1 and bandkss/=0, then, the DFT+DMFT calculation is not done and only projections are computed at the end
of the calculation. They can be used by an external code or used to compute the screened interaction (see variable <a href="vargw.html#ucrpa">ucrpa</a>).



</font>

<br><br><br><br><a href=#top>Go to the top</a>
<B> | </B><a href="keyhr.html#list">Complete list of input variables</a><hr>

<br><font id="title"><a name="use_gemm_nonlop">use_gemm_nonlop</a></font>
<br><font id="definition">Mnemonics: USE the GEMM routine for the application of the NON-Local OPerator</font>
<br><font id="category">Characteristic: <a href="../users/abinit_help.html#develop">DEVELOP</a>  </font>
<br><font id="vartype">Variable type: integer parameter  </font>
<br><font id="default">Default is 0 because it is not usually worth using it unless bandpp is large and it requires additional memory </font>
<br><font id="text">
<p>This keyword tells abinit to use a BLAS routine to speed up the computation of the non-local operator. This requires the precomputation of a large matrix, and has a significant memory overhead. In exchange, it provides improved performance when used on several bands at once (Chebyshev or LOBPCG algorithm with <a href="varpar.html#bandpp"> bandpp</a> &gt; 1). Turning this option on might be up to two times as slow for one band (because it performs additional FLOPS), but can be up to 5x faster when bandpp is increased.</p>
<p> The memory overhead is proportional to the number of atoms, the number of plane waves, and the number of projectors per atom. It can be mitigated by distributing the array with <a href="varpar.html#npfft">npfft.</a></p>
<p> The performance depends crucially on having a good BLAS installed. Provided the BLAS supports OpenMP, this option also yields very good scaling for the nonlocal operator.</p>
</font>

<br><br><br><br><a href=#top>Go to the top</a>
<B> | </B><a href="keyhr.html#list">Complete list of input variables</a><hr>

<br><font id="title"><a name="use_nonscf_gkk">use_nonscf_gkk</a></font>
<br><font id="definition">Mnemonics: USE NON-SCF calculation of GKK matrix elements (electron phonon)</font>
<br><font id="category">Characteristic: <a href="../users/abinit_help.html#develop">DEVELOP</a>  </font>
<br><font id="vartype">Variable type: integer parameter  </font>
<br><font id="default">Default is 0 for the moment (do not use non-scf method) For old behavior set to 0.</font>
<br><font id="text">
<p>
When this flag is activated during a phonon calculation with abinit, all of the perturbations are cycled through, but only the symmetry-irreducible ones are calculated self-consistently. For the others the perturbed density is rotated by the appropriate symop and the gkk matrix elements are calculated non-self-consistently. As they do not depend on the perturbed wave functions, they are correct from the first iteration, and nstep is set to 1 for those perturbations. Note that the resulting 1DEN files are simply the rotate/symmetric ones and that the resulting 1WF files are garbage (completely unconverged) except the matrix elements in the header (equivalent to GKK files, but please use the latter much smaller files for el-ph calculations). The new default behavior with use_nonscf_gkk = 1 should be transparent for the user, with the same output files but a much quicker execution. </p>
<p>Caveant: Note that very tight convergence of ground state and phonon calculations is necessary to get good GKK matrix elements! <a href="varbas.html#tolwfr">tolwfr</a> = 1.e-24 or so is recommended everywhere. There may be problems using use_nonscf_gkk = 1 with non-symmorphic symmetries - please check (at least) that lifetimes for phonons go to 0 for acoustic modes at Gamma.</p>
</font>

<br><br><br><br><a href=#top>Go to the top</a>
<B> | </B><a href="keyhr.html#list">Complete list of input variables</a><hr>

<br><font id="title"><a name="useri">useria, userib, useric, userid, userie</a></font>
<br><font id="definition">Mnemonics: USER Integer variables A, B, C, D and E </font>
<br><font id="category">Characteristic:  </font>
<br><font id="vartype">Variable type: integers </font>
<br><font id="default">Default is 0 .</font>
<br><font id="text">
<p>
These are user-definable integers which the user may
input and then utilize in subroutines of his/her own
design.  They are not used in the official versions
of the ABINIT code, and should ease independent
developments (hopefully integrated in the official
version afterwards).
<br>Internally, they are available in the dtset structured datatype,
e.g. dtset%useria .
</font>

<br><br><br><br><a href=#top>Go to the top</a>
<B> | </B><a href="keyhr.html#list">Complete list of input variables</a><hr>


<br><font id="title"><a name="userr">userra, userrb, userrc, userrd, userre</a></font>
<br><font id="definition">Mnemonics: USER Real variables A, B, C, D, and E </font>
<br><font id="category">Characteristic:  </font>
<br><font id="vartype">Variable type: real numbers</font>
<br><font id="default">Default is 0.0 .</font>
<br><font id="text">
<p>
These are user-definable with the same purpose as <a href="vardev.html#useri">useri</a>. </font>


<br><br><br><br><a href=#top>Go to the top</a>
<B> | </B><a href="keyhr.html#list">Complete list of input variables</a><hr>

<br><font id="title"><a name="useylm">useylm</a></font>
<br><font id="definition">Mnemonics: USE YLM (the spherical harmonics) </font>
 <br><font id="category">Characteristic: <a href="../users/abinit_help.html#develop">DEVELOP</a>  </font>
 <br><font id="vartype">Variable type: integer parameter  </font>
<br><font id="default">Default is 0 for norm-conserving pseudopotential(s), 1 for Projector Augmented-Wave (PAW), 1 when the recursion method is used (<a href="vardev.html#tfkinfunc">tfkinfunc</a>=1).</font>
 <br><font id="text">
 <p>
When this flag is activated, the non-local operator is applied using an algorithm based on spherical harmonics. Non-local projectors are used with their usual form:<br>
<ul>P<sub>lmn</sub>(r)=Y<sub>lm</sub>(r)*p<sub>ln</sub>(r)</ul><br>
<br>When <b>useylm</b>=0, the sum over Y_lm can be reduced to a Legendre polynomial form.
 </font>

<br><br><br><br><a href=#top>Go to the top</a>
<B> | </B><a href="keyhr.html#list">Complete list of input variables</a><hr>


<font id="title"><a name="vdw_df_acutmin">vdw_df_acutmin</a></font>
<br><font id="definition">Mnemonics: vdW-DF MINimum Angular CUT-off</font>
<br><font id="category">Characteristic: <a href="../users/abinit_help.html#develop">DEVELOP</a> </font>
<br><font id="vartype">Variable type: real number </font>
<br><font id="default">Default is 10.</font>
<br><br><font id="text">Used when <a href="vardev.html#vdw_xc">vdw_xc</a>&gt;0,
to build angular meshes for the vdW-DF kernel.<br/>
</font>

<br><br><br><br><a href=#top>Go to the top</a>
<B> | </B><a href="keyhr.html#list">Complete list of input variables</a><hr>


<font id="title"><a name="vdw_df_aratio">vdw_df_aratio</a></font>
<br><font id="definition">Mnemonics: vdW-DF RATIO between the highest and
lowest Angle.</font>
<br><font id="category">Characteristic: <a href="../users/abinit_help.html#develop">DEVELOP</a> </font>
<br><font id="vartype">Variable type: real number </font>
<br><font id="default">Default is 30.</font>
<br><br><font id="text">Used when <a href="vardev.html#vdw_xc">vdw_xc</a>&gt;0,
to build angular meshes for the vdW-DF kernel.<br/>
</font>

<br><br><br><br><a href=#top>Go to the top</a>
<B> | </B><a href="keyhr.html#list">Complete list of input variables</a><hr>


<font id="title"><a name="vdw_df_damax">vdw_df_damax</a></font>
<br><font id="definition">Mnemonics: vdW-DF MAXimum Angular Delta</font>
<br><font id="category">Characteristic: <a href="../users/abinit_help.html#develop">DEVELOP</a> </font>
<br><font id="vartype">Variable type: real number </font>
<br><font id="default">Default is 0.5.</font>
<br><br><font id="text">Used when <a href="vardev.html#vdw_xc">vdw_xc</a>&gt;0,
to build angular meshes for the vdW-DF kernel.<br/>
</font>

<br><br><br><br><a href=#top>Go to the top</a>
<B> | </B><a href="keyhr.html#list">Complete list of input variables</a><hr>

<font id="title"><a name="vdw_df_damin">vdw_df_damin</a></font>
<br><font id="definition">Mnemonics: vdW-DF MINimum Angular Delta</font>
<br><font id="category">Characteristic: <a href="../users/abinit_help.html#develop">DEVELOP</a> </font>
<br><font id="vartype">Variable type: real number </font>
<br><font id="default">Default is 1.0e-2.</font>
<br><br><font id="text">Used when <a href="vardev.html#vdw_xc">vdw_xc</a>&gt;0,
to build angular meshes for the vdW-DF kernel.<br/>
</font>

<br><br><br><br><a href=#top>Go to the top</a>
<B> | </B><a href="keyhr.html#list">Complete list of input variables</a><hr>


<font id="title"><a name="vdw_df_dcut">vdw_df_dcut</a></font>
<br><font id="definition">Mnemonics: vdW-DF D-mesh CUT-off</font>
<br><font id="category">Characteristic: <a href="../users/abinit_help.html#develop">DEVELOP</a> </font>
<br><font id="vartype">Variable type: real number </font>
<br><font id="default">Default is 30.</font>
<br><br><font id="text">Used when <a href="vardev.html#vdw_xc">vdw_xc</a>&gt;0,
to build the vdW-DF kernel.<br/>
</font>

<br><br><br><br><a href=#top>Go to the top</a>
<B> | </B><a href="keyhr.html#list">Complete list of input variables</a><hr>


<font id="title"><a name="vdw_df_dratio">vdw_df_dratio</a></font>
<br><font id="definition">Mnemonics: vdW-DF RATIO between the highest and
lowest D.</font>
<br><font id="category">Characteristic: <a href="../users/abinit_help.html#develop">DEVELOP</a> </font>
<br><font id="vartype">Variable type: real number </font>
<br><font id="default">Default is 20.</font>
<br><br><font id="text">Used when <a href="vardev.html#vdw_xc">vdw_xc</a>&gt;0,
to build the vdW-DF kernel.<br/>
</font>

<br><br><br><br><a href=#top>Go to the top</a>
<B> | </B><a href="keyhr.html#list">Complete list of input variables</a><hr>


<font id="title"><a name="vdw_df_dsoft">vdw_df_dsoft</a></font>
<br><font id="definition">Mnemonics: vdW-DF SOFTening distance.</font>
<br><font id="category">Characteristic: <a href="../users/abinit_help.html#develop">DEVELOP</a> </font>
<br><font id="vartype">Variable type: real number </font>
<br><font id="default">Default is 1.0.</font>
<br><br><font id="text">Used when <a href="vardev.html#vdw_xc">vdw_xc</a>&gt;0,
to build the vdW-DF kernel.<br/>
</font>

<br><br><br><br><a href=#top>Go to the top</a>
<B> | </B><a href="keyhr.html#list">Complete list of input variables</a><hr>


<font id="title"><a name="vdw_df_gcut">vdw_df_gcut</a></font>
<br><font id="definition">Mnemonics: vdW-DF K-space CUT-off</font>
<br><font id="category">Characteristic: <a href="../users/abinit_help.html#develop">DEVELOP</a> </font>
<br><font id="vartype">Variable type: real number </font>
<br><font id="default">Default is 5.</font>
<br><br><font id="text">Used when <a href="vardev.html#vdw_xc">vdw_xc</a>&gt;0,
to filter the vdW-DF kernel in reciprocal space.<br/>
</font>

<br><br><br><br><a href=#top>Go to the top</a>
<B> | </B><a href="keyhr.html#list">Complete list of input variables</a><hr>


<font id="title"><a name="vdw_df_ndpts">vdw_df_ndpts</a></font>
<br><font id="definition">Mnemonics: vdW-DF Number of D-mesh PoinTS</font>
<br><font id="category">Characteristic: <a href="../users/abinit_help.html#develop">DEVELOP</a> </font>
<br><font id="vartype">Variable type: integer parameter </font>
<br><font id="default">Default is 20.</font>
<br><br><font id="text">Used when <a href="vardev.html#vdw_xc">vdw_xc</a>&gt;0,
to build the vdW-DF kernel.<br/>
</font>

<br><br><br><br><a href=#top>Go to the top</a>
<B> | </B><a href="keyhr.html#list">Complete list of input variables</a><hr>

<font id="title"><a name="vdw_df_ngpts">vdw_df_ngpts</a></font>
<br><font id="definition">Mnemonics: vdW-DF Number of G-mesh PoinTS</font>
<br><font id="category">Characteristic: <a href="../users/abinit_help.html#develop">DEVELOP</a> </font>
<br><font id="vartype">Variable type: integer parameter </font>
<br><font id="default">Default is -1.</font>
<br><br><font id="text">Used when <a href="vardev.html#vdw_xc">vdw_xc</a>&gt;0,
to build the vdW-DF kernel.<br/>
</font>

<br><br><br><br><a href=#top>Go to the top</a>
<B> | </B><a href="keyhr.html#list">Complete list of input variables</a><hr>


<font id="title"><a name="vdw_df_nqpts">vdw_df_nqpts</a></font>
<br><font id="definition">Mnemonics: vdW-DF Number of Q-mesh PoinTS</font>
<br><font id="category">Characteristic: <a href="../users/abinit_help.html#develop">DEVELOP</a> </font>
<br><font id="vartype">Variable type: integer parameter </font>
<br><font id="default">Default is 30.</font>
<br><br><font id="text">Used when <a href="vardev.html#vdw_xc">vdw_xc</a>&gt;0,
to build the vdW-DF kernel.<br/>
</font>

<br><br><br><br><a href=#top>Go to the top</a>
<B> | </B><a href="keyhr.html#list">Complete list of input variables</a><hr>


<font id="title"><a name="vdw_df_nrpts">vdw_df_nrpts</a></font>
<br><font id="definition">Mnemonics: vdW-DF Number of R-PoinTS</font>
<br><font id="category">Characteristic: <a href="../users/abinit_help.html#develop">DEVELOP</a> </font>
<br><font id="vartype">Variable type: integer parameter </font>
<br><font id="default">Default is 2048.</font>
<br><br><font id="text">Used when <a href="vardev.html#vdw_xc">vdw_xc</a>&gt;0,
to define the sampling of the vdW-DF-kernel in real-space.<br/>
</font>

<br><br><br><br><a href=#top>Go to the top</a>
<B> | </B><a href="keyhr.html#list">Complete list of input variables</a><hr>


<font id="title"><a name="vdw_df_nsmooth">vdw_df_nsmooth</a></font>
<br><font id="definition">Mnemonics: vdW-DF Number of SMOOTHening iterations</font>
<br><font id="category">Characteristic: <a href="../users/abinit_help.html#develop">DEVELOP</a> </font>
<br><font id="vartype">Variable type: integer parameter </font>
<br><font id="default">Default is 12.</font>
<br><br><font id="text">Used when <a href="vardev.html#vdw_xc">vdw_xc</a>&gt;0,
to exponentially smoothen q near q0.<br/>
</font>

<br><br><br><br><a href=#top>Go to the top</a>
<B> | </B><a href="keyhr.html#list">Complete list of input variables</a><hr>

<font id="title"><a name="vdw_df_phisoft">vdw_df_phisoft</a></font>
<br><font id="definition">Mnemonics: vdW-DF SOFTening PHI value.</font>
<br><font id="category">Characteristic: <a href="../users/abinit_help.html#develop">DEVELOP</a> </font>
<br><font id="vartype">Variable type: real number </font>
<br><font id="default">Default is -1.0.</font>
<br><br><font id="text">Used when <a href="vardev.html#vdw_xc">vdw_xc</a>&gt;0,
to build the vdW-DF kernel.<br/>
</font>

<br><br><br><br><a href=#top>Go to the top</a>
<B> | </B><a href="keyhr.html#list">Complete list of input variables</a><hr>


<font id="title"><a name="vdw_df_qcut">vdw_df_qcut</a></font>
<br><font id="definition">Mnemonics: vdW-DF Q-mesh CUT-off</font>
<br><font id="category">Characteristic: <a href="../users/abinit_help.html#develop">DEVELOP</a> </font>
<br><font id="vartype">Variable type: real number </font>
<br><font id="default">Default is 5.</font>
<br><br><font id="text">Used when <a href="vardev.html#vdw_xc">vdw_xc</a>&gt;0,
to build the vdW-DF kernel.<br/>
</font>

<br><br><br><br><a href=#top>Go to the top</a>
<B> | </B><a href="keyhr.html#list">Complete list of input variables</a><hr>


<font id="title"><a name="vdw_df_qratio">vdw_df_qratio</a></font>
<br><font id="definition">Mnemonics: vdW-DF RATIO between highest and
lowest Q</font>
<br><font id="category">Characteristic: <a href="../users/abinit_help.html#develop">DEVELOP</a> </font>
<br><font id="vartype">Variable type: real number </font>
<br><font id="default">Default is 20.</font>
<br><br><font id="text">Used when <a href="vardev.html#vdw_xc">vdw_xc</a>&gt;0,
.<br/>
</font>

<br><br><br><br><a href=#top>Go to the top</a>
<B> | </B><a href="keyhr.html#list">Complete list of input variables</a><hr>


<font id="title"><a name="vdw_df_rcut">vdw_df_rcut</a></font>
<br><font id="definition">Mnemonics: vdW-DF Real-space CUT-off</font>
<br><font id="category">Characteristic: <a href="../users/abinit_help.html#develop">DEVELOP</a> </font>
<br><font id="vartype">Variable type: real number </font>
<br><font id="default">Default is 100.</font>
<br><br><font id="text">Used when <a href="vardev.html#vdw_xc">vdw_xc</a>&gt;0,
to define the vdW-DF kernel cut-off radius.<br/>
</font>

<br><br><br><br><a href=#top>Go to the top</a>
<B> | </B><a href="keyhr.html#list">Complete list of input variables</a><hr>

<font id="title"><a name="vdw_df_rsoft">vdw_df_rsoft</a></font>
<br><font id="definition">Mnemonics: vdW-DF SOFTening radius.</font>
<br><font id="category">Characteristic: <a href="../users/abinit_help.html#develop">DEVELOP</a> </font>
<br><font id="vartype">Variable type: real number </font>
<br><font id="default">Default is 0.0.</font>
<br><br><font id="text">Used when <a href="vardev.html#vdw_xc">vdw_xc</a>&gt;0,
to build the vdW-DF kernel.<br/>
</font>

<br><br><br><br><a href=#top>Go to the top</a>
<B> | </B><a href="keyhr.html#list">Complete list of input variables</a><hr>


<font id="title"><a name="vdw_df_threshold">vdw_df_threshold</a></font>
<br><font id="definition">Mnemonics: vdW-DF energy calculation threshold</font>
<br><font id="category">Characteristic: <a href="../users/abinit_help.html#develop">DEVELOP</a> </font>
<br><font id="vartype">Variable type: real parameter  </font>
<br><font id="default">Default is 1.0e-2</font>
<br><br><font id="text">Sets a threshold for the energy gradient that,
when reached, will cause the vdW-DF interactions to be calculated. This
makes sense only if <a href="vardev.html#vdw_xc">vdw_xc</a> is non-zero.
<br>Adjust it to a big value (e.g. 1e12) to enable it all along the SCF
calculation. Too small values, as well as negative values, will result
in the vdW-DF energy contributions never being calculated.
</font>

<br><br><br><br><a href="#top">Go to the top</a>
<B> | </B><a href="keyhr.html#list">Complete list of input variables</a><hr>

<font id="title"><a name="vdw_df_tolerance">vdw_df_tolerance</a></font>
<br><font id="definition">Mnemonics: vdW-DF global TOLERANCE.</font>
<br><font id="category">Characteristic: <a href="../users/abinit_help.html#develop">DEVELOP</a> </font>
<br><font id="vartype">Variable type: real number </font>
<br><font id="default">Default is 1.0e-13.</font>
<br><br><font id="text">Used when <a href="vardev.html#vdw_xc">vdw_xc</a>&gt;0,
to build the vdW-DF kernel.<br/>
</font>

<br><br><br><br><a href=#top>Go to the top</a>
<B> | </B><a href="keyhr.html#list">Complete list of input variables</a><hr>

<font id="title"><a name="vdw_df_tweaks">vdw_df_tweaks</a></font>
<br><font id="definition">Mnemonics: vdW-DF tweaks.</font>
<br><font id="category">Characteristic: <a href="../users/abinit_help.html#develop">DEVELOP</a> </font>
<br><font id="vartype">Variable type: integer parameter </font>
<br><font id="default">Default is 0.</font>
<br><br><font id="text">Used when <a href="vardev.html#vdw_xc">vdw_xc</a>&gt;0,
to build the vdW-DF kernel.<br/>
<b><i>IMPORTANT NOTE: modifying this variable will likely transform the calculated energies and their gradients into garbage. You have been warned!</i></b><br/>
</font>

<br><br><br><br><a href=#top>Go to the top</a>
<B> | </B><a href="keyhr.html#list">Complete list of input variables</a><hr>

<font id="title"><a name="vdw_df_zab">vdw_df_zab</a></font>
<br><font id="definition">Mnemonics: vdW-DF Zab parameter </font>
<br><font id="category">Characteristic: <a href="../users/abinit_help.html#develop">DEVELOP</a> </font>
<br><font id="vartype">Variable type: real number </font>
<br><font id="default">Default is -0.8491.</font>
<br><br><font id="text">Used when <a href="vardev.html#vdw_xc">vdw_xc</a>&gt;0,
as inctroduced in <a href="http://dx.doi.org/10.1103/PhysRevLett.92.246401">doi:10.1103/PhysRevLett.92.246401</a>.<br/>
</font>

<br><br><br><br><a href=#top>Go to the top</a>
<B> | </B><a href="keyhr.html#list">Complete list of input variables</a><hr>


<br><font id="title"><a name="vdw_nfrag">vdw_nfrag</a></font>
<br><font id="definition">Mnemonics: van der Waals Number of interacting FRAGments</font>
<br><font id="category">Characteristic: DEVELOP</font>
<br><font id="vartype">Variable type: integer vdw_nfrag </font>
<br><font id="default">Default is 1</font>
<br><font id="text">
<p>
The absolute value of vdw_nfrag is the number of vdW interacting
  fragments in the unit cell. As wannierization takes place in reciprocal space, the MLWF
  center positions could be translated by some lattice vector from the cell where atoms
  are placed. If vdw_nfrag >= 1 then MLWFs are translated to the original
  unit cell, otherwise the program will keep the positions obtained by Wannier90. The
  later is usually correct if some atoms are located at the corners or at limiting
  faces of the unit cell.

  Used only if <b>vdw_xc=</b>10,11.
</font>

<br><br><br><br><a href=#top>Go to the top</a>
<B> | </B><a href="keyhr.html#list">Complete list of input variables</a><hr>


<br><font id="title"><a name="vdw_tol">vdw_tol</a></font>
<br><font id="definition">Mnemonics: van der Waals TOLerance</font>
<br><font id="category">Characteristic: DEVELOP</font>
<br><font id="vartype">Variable type: real number </font>
<br><font id="default">Default is 10^-10</font>
<br><font id="text">
<p>
Used only when Van der Waals DFT-D2 correction is activated (<a href="vardev.html#vdw_xc">vdw_xc</a>=5).<br>
The DFT-D2 (S. Grimme approach) dispersion potential is implemented as a pair potential.
The number of pairs of atoms contributing to the potential is necessarily limited. To be included
in the potential a pair of atom must have contribution to the energy larger than <b>vdw_tol</b>.
</font>

<br><br><br><br><a href=#top>Go to the top</a>
<B> | </B><a href="keyhr.html#list">Complete list of input variables</a><hr>


<br><font id="title"><a name="vdw_typfrag">vdw_typfrag</a></font>
<br><font id="definition">Mnemonics: van der Waals TYPe of FRAGment</font>
<br><font id="category">Characteristic: DEVELOP</font>
<br><font id="vartype">Variable type: integer array vdw_typfrag(natom) </font>
<br><font id="default">Default is 1*natom</font>
<br><font id="text">
<p>
This array defines the interacting fragments by assigning to each atom an
 integer index from 1 to <b>vdw_nfrag</b>. The ordering of <b>vdw_typfrag</b> is the same as
 <a href="varbas.html#typat">typat</a> or <a href="varbas.html#xcart">xcart</a>. Internally each MLWF is
 assigned to a given fragment by computing the distance to the atoms. MLWFs belong to
 the same fragment as their nearest atom. The resulting set of MLWFs in each interacting fragment
 can be found in the output file in xyz format for easy visualization.

 Used only if <b>vdw_xc</b>=10,11.
</font>

<br><br><br><br><a href=#top>Go to the top</a>
<B> | </B><a href="keyhr.html#list">Complete list of input variables</a><hr>


<br><font id="title"><a name="vdw_supercell">vdw_supercell</a></font>
<br><font id="definition">Mnemonics: Van Der Waals correction from Wannier functions in SUPERCELL</font>
<br><font id="category">Characteristic: DEVELOP</font>
<br><font id="vartype">Variable type: integer array vdw_supercell(3) </font>
<br><font id="default">Default is 0 0 0</font>
<br><font id="text">
<p>
Set of dimensionless positive numbers which define the maximum multiples
  of the primitive translations (rprimd) in the supercell construction. Each component of vdw_supercell
  indicates the maximum number of cells along both positive or negative directions of the corresponding
  primitive vector i.e. the components of <a href="varbas.html#rprimd">rprimd</a>. In the case of layered
  systems for which vdW interactions occur between layers made of tightly bound atoms, the evaluation
  of vdW corrections comming from MLWFs in the same layer (fragment) must be avoided. Both a negative or
  null value for one component of <b>vdw_supercell</b>  will indicate that the  corresponding direction
  is normal to the layers.


  Used only if <b>vdw_xc</b>=10,11.
</font>

<br><br><br><br><a href=#top>Go to the top</a>
<B> | </B><a href="keyhr.html#list">Complete list of input variables</a><hr>


<br><font id="title"><a name="vdw_xc">vdw_xc</a></font>
<br><font id="definition">Mnemonics: van der Waals eXchange-Correlation functional</font>
<br><font id="category">Characteristic: DEVELOP</font>
<br><font id="vartype">Variable type: integer  </font>
<br><font id="default">Default is 0</font>
<br><font id="text">
<p>
Selects a van-der-Waals density functional to
apply the corresponding correction to the exchange-correlation energy.
If set to zero, no correction will be applied.
<br>
Possible values are:
<ul>
  <li>0: no correction.</li>
  <li>1: apply vdW-DF1 (DRSLL) from Dion <i>et al.</i><br>
      <i>doi:10.1103/PhysRevLett.92.246401</i></li>
  <li>2: apply vdw-DF2 (LMKLL) from Lee <i>et al.</i><br>
      <i>arXiv:1003.5255v1</i></li>
  <li>5: apply vdw-DFT-D2 as proposed by S. Grimme (adding a semi-empirical dispersion potential)<br>
      Available only for ground-state calculations ; see <a href="vardev.html#vdw_tol">vdw_tol</a> variable
      to control convergency<br>
      <i>J. Comp. Chem. 27, 1787 (2006)</i></li>
  <li>10: evaluate the vdW correlation energy from maximally localized Wannier functions, as proposed by
  P. L. Silvestrelli, also known as vdW-WF1 method.<br> 
     <i>doi:10.1103/PhysRevLett.100.053002.</i> For details on this implementation please check: <i>doi:10.1016/j.cpc.2011.11.003</i><br>
  The improvements introduced by Andrinopoulos <i>et al.</i> in <i> J. Chem. Phys. 135, 154105 (2011)</i> namely 
  the amalgamation procedure, splitting of p-like MLWFs 
  into <br> two s-like Wannier functions and fractional occupation of MLWFs are performed automatically.<br></li>

  <li>11: evaluate the vdW correlation energy from maximally localized Wannier functions, as proposed by
  A. Ambrosetti and P. L. Silvestrelli, also known as vdW-WF2 method.<br> 
      <i>doi:10.1103/PhysRevB.85.073101</i></li>
  <li>14: apply DFT/vdW-QHO-WF method as proposed by Silvestrelli, which combines the quantum harmonic 
  oscillator-model with localized Wannier functions. <br>
      <i>J. Chem. Phys. 139, 054106 (2013) </i><br>
  For periodic systems a supercell approach has to be used since <b>vdw_supercell</b> is not enabled in this case. 
   </li> 
</ul>
For vdw_xc=1 and vdw_xc=2, the implementation follows the strategy devised
in the article of Rom&aacute;n-P&eacute;rez and Soler
(doi:10.1103/PhysRevLett.103.096102).
</font>

<br><br><br><br><a href=#top>Go to the top</a>
<B> | </B><a href="keyhr.html#list">Complete list of input variables</a><hr>


<br><font id="title"><a name="wfoptalg">wfoptalg</a></font>
<br><font id="definition">Mnemonics: WaveFunction OPTimisation ALGorithm </font>
<br><font id="category">Characteristic: <a href="../users/abinit_help.html#develop">DEVELOP</a>  </font>
<br><font id="vartype">Variable type: integer parameter  </font>
<br><font id="default">Default is 0 when <a href="varint.html#usepaw">usepaw</a>=0 (norm-conserving pseudopotentials),<br>10 when <a href="varint.html#usepaw">usepaw</a>=1 (PAW).<br>Default is 14 if <a href="varpar.html#paral_kgb">paral_kgb</a>=1.</font>
<br><font id="text">
<p>
 Allows to choose the algorithm
for the optimisation of the wavefunctions.
<br>The different possibilities are :
<ul>
<li><b>wfoptalg</b>=0 : standard state-by-state conjugate gradient algorithm,
 with no possibility to parallelize over the states;</li>
<li><b>wfoptalg</b>=2 : minimisation of the residual with respect
 to different shifts, in order to cover the whole set of occupied
 bands, with possibility to parallelize over blocks of states (or bands).
 The number of states in a block
 is defined in <a href="vardev.html#nbdblock">nbdblock</a>.
 THIS IS STILL IN DEVELOPMENT.</li>
<li><b>wfoptalg</b>=3 : minimisation of the residual with respect
 to a shift. Available only in the non-self-consistent case
 <a href="varbas.html#iscf">iscf</a>=-2,
 in order to find eigenvalues and wavefunctions close to a
 prescribed value.</li>
<li><b>wfoptalg</b>=4 : (see also <b>wfoptalg</b>=14), a parallel code based on the Locally Optimal
Block Preconditioned Conjugate Gradient (LOBPCG) method of Knyazev.
<a href="http://dx.doi.org/10.1137/S1064827500366124">
Reference : A.V. Knyazev, "Toward the Optimal Preconditioned Eigensolver
: Locally Optimal Block Preconditioned Conjugate Gradient Method". SIAM
Journal on Scientific Computing 23, pp517-541 (2001)</a>.
The implementation rests
on the <a href="http://www.mathworks.com/matlabcentral/fileexchange/48-lobpcg-m">
matlab program by Knyazev</a>.
<a href="http://dx.doi.org/10.1137/060661624">
Reference A. V. Knyazev, I. Lashuk, M. E. Argentati, and E. Ovchinnikov,
Block Locally Optimal Preconditioned Eigenvalue Xolvers (BLOPEX) in
hypre and PETSc (2007). SIAM Journal on Scientific Computing (SISC).
25(5): 2224-2239</a>.
For more
information see
<a href="http://dx.doi.org/10.1016/j.commatsci.2007.07.019">
F. Bottin, S. Leroux, A. Knyazev, G. Zerah, Large scale
ab initio calculations based on three levels of parallelization. (2008).
Computational Material Science, 42(2), 329-336.
</a>
<li><b>wfoptalg</b>=10 : (for PAW) standard state-by-state conjugate gradient algorithm,
 with no possibility to parallelize over the states, but modified
 scheme described in Kresse, Furthmuller, PRB 54, 11169 (1996)
 (modified kinetic energy, modified preconditionning, minimal
  orthogonalization, ...) ;</li>
<li><b>wfoptalg</b>=14 :
 the recommended for parallel code, the same as <b>wfoptalg</b>=4 except that the preconditioning of
 the block vectors does not depend on the kinetic energy of each band,
 and the orthogonalization after the LOBPCG algorithm is no longer
 performed. The first modification increases the convergence and the
 second one the efficiency.
</li>
<li><b>wfoptalg</b>=1 :
 new algorithm based on Chebyshev filtering, designed for very large number of processors, in the regime where LOBPCG does not scale anymore. It is not able to use preconditionning and therefore might converge slower than other algorithms. By design, it will <b>not</b> converge the last bands: it is recommended to use slightly more bands than necessary. For usage with <a href="varbas.html#tolwfr">tolwfr</a>, it is imperative to use <a href="vargs.html#nbdbuf">nbdbuf</a>. For more performance, try <a href="vardev.html#use_gemm_nonlop">use_gemm_nonlop</a>. For more information, see the <a href="../theory/howto_chebfi.pdf">performance guide</a> and the <a href="http://arxiv.org/abs/1406.4350">paper</a> by A. Levitt and M. Torrent. Status: experimental but usable. Questions and bug reports should be sent to antoine (dot) levitt (at) gmail.com.
</li>
</ul>
</font>

<br><br><br><br><a href=#top>Go to the top</a>
<B> | </B><a href="keyhr.html#list">Complete list of input variables</a><hr>

<br><font id="title"><a name="xc_denpos">xc_denpos</a></font>
<br><font id="definition">Mnemonics: eXchange-Correlation - DENsity POSitivity value  </font>
<br><font id="category">Characteristic: <a href="../users/abinit_help.html#develop">DEVELOP</a>  </font>
<br><font id="vartype">Variable type: real</font>
<br><font id="default">Default is 1.0e-14 </font>
<br><font id="text">
<p>
For the evaluation of the exchange-correlation functionals, the density
cannot be negative, or even too small (e.g. the LDA exchange kernel
behaves like the density at power -(2/3), and the density is used at the denominator
of different factors in GGAs and metaGGAs.
<b>xc_denpos</b> is the smallest value that the density can assume at the time of the
evaluation of a XC functional, in ABINIT. When then computed density drops below <b>xc_denpos</b>
before attacking the evaluation of the XC functional, then it will be (only for that purpose)
replaced by <b>xc_denpos</b>. Note that the evaluation of the gradients or other quantities
that are density-dependent is performed before this replacement.
<p>
It has been observed that the SCF cycle of the Tran-Blaha mGGA can be quite hard to make converge, for systems
for which there is some vacuum. In this case, setting <b>xc_denpos</b> to 1.0e-7 ... 1.0e-6 has been seen
to allow good convergence. Of course, this will affect the numerical results somehow, and one should play
a bit with this value to avoid incorrect calculations.
</font>


<br><br><br><br><a href=#top>Go to the top</a>
<B> | </B><a href="keyhr.html#list">Complete list of input variables</a>

<br><font id="title"><a name="xc_tb09_c">xc_tb09_c</a></font>
<br><font id="definition">Mnemonics: Value of the c parameter in the eXchange-Correlation TB09 functional </font>
<br><font id="category">Characteristic: </a> </font>
<br><font id="vartype">Variable type: real </font>
<br><font id="default">Default is all 99.99d0</font>
<br><font id="text">
<p>
The modified Becke-Johnson exchange-correlation functional by Tran and Blaha (Phys. Rev. Lett. 102, 226401 (2009)) reads :
<p>V_x(r) = c * V_x^{BR}(r) + (3*c - 2) * 1/pi * sqrt(5/12) * sqrt(2*kden(r)/den(r))
<p>in which V_x^{BR}(r) is the Becke-Roussel potential.
<p>In this equation the parameter c can be evaluated at each SCF step according to the following equation :
<p>c = alpha + beta * sqrt(1/V_{cell} * \int_{V_{cell}} |grad(den(r))|/den(r) d3r)
<p>The c parameter is evaluated thanks to the previous equation when xc_tb09_c is equal to the "magic" default value 99.99.
The c parameter can also be fixed to some (property-optimized or material-optimized) value by using this variable.
</font>


<br><br><br><br><a href="#top">Go to the top</a>
<B> | </B><a href="keyhr.html#list">Complete list of input variables</a><hr>


<script type="text/javascript" src="list_internal_links.js"> </script>

</body>
</html>

